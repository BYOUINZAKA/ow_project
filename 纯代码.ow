变量
{
	全局:
		0: random
		1: t_enum_hp_pool
		2: t_enum_damage_adjust
		3: t_enum_heal_adjust
		4: t_enum_effect
		5: t_enum_speed
		6: t_enum_move_cd
		7: t_enum_map_text
		8: t_enum_assists
		9: t_enum_status_thorns
		10: t_enum_disable_button
		20: args_tracer
		21: args_zenyata
		22: args_reaper
		23: cd_lucio_cd_dec
		24: ch_normal_attack_dist
		25: ca_zenyata_armor_heros
		26: ci_mei_shift_heal
		27: ci_mei_shift_heal_time
		28: args_ana
		29: args_ramattra
		30: args_junkerqueen
		100: args_system

	玩家:
		0: d_sys_cd
		1: i_sys_pre_speed
		2: i_sys_speed
		3: a_sys_flags
		4: a_sys_enemy_flags
		5: tracer_energy
		6: tracer_energy_reset
		7: tracer_energy_last
		8: tracer_hit
		9: tracer_hit_last
		10: reinhardt_shield
		11: i_sys_assists
		12: torbjorn_Q_flag
		13: torbjorn_Q_begin
		14: kiriko_heal_target
		15: mei_Q_timer
		16: mei_s_flag
		17: mei_Q_dec
		18: reaper_shadow
		19: hanzo_focus
		20: buligita_players
		21: roadhog_mates_flag
		22: roadhog_hit_flag
		23: mei_s_begin_time
		30: lucio_debuff_clear
		31: lucio_slice_dec
		32: lucio_players
		35: a_sys_ultimate_efficiency
		36: cassidy_distance
		40: sombra_demage
		41: sombra_timer
		42: sombra_player
		43: sombra_hacked
		45: dva_armor_recover
		50: wrecking_ball_dec
		51: wrecking_ball_players
		52: wrecking_ball_dec_id
		60: orisa_teammates
		63: orisa_master
		65: sigma_battery_pos
		66: sigma_battery_pic
		67: sigma_battery_target
		70: baptiste_shift_hp
		71: zenyata_target
		72: ramattra_absorb
		73: ramattra_absorb_id
		74: null_74
		75: illari_poison
		76: illari_i
		77: soldier76_e_begin
		78: zenyata_flag
		80: winston_power
		85: zarya_hp_record
		86: zarya_hp_record_tmp
		87: zarya_weaken
		88: zarya_heal_inc
		90: sojourn_Q_demage_count
		91: sojourn_bullet_count
		95: symmetra_Q_effect
		96: symmetra_Q_players
		97: symmetra_Q_inedx
		98: symmetra_demage
		99: ana_q_flag
		100: debug_robot
		101: debug_1
		102: debug_2
		103: sys_data_record
		104: debug_robot2
		105: sys_default_status_pool
		106: d_sys_status_thorns
		107: sys_default_status_pool_i
		109: sys_self_text
		110: junkerqueen_effect
		111: junkerqueen_timer
		112: junkerqueen_players
		113: junkerqueen_flag
		120: widowmaker_hp_pool
		121: widowmaker_hp_pool_timer
}

子程序
{
	0: remove_default_status
}

规则("常量")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.t_enum_hp_pool = 1;
		全局.t_enum_damage_adjust = 2;
		全局.t_enum_heal_adjust = 3;
		全局.t_enum_effect = 4;
		全局.t_enum_speed = 5;
		全局.t_enum_move_cd = 6;
		全局.t_enum_map_text = 7;
		全局.t_enum_assists = 8;
		全局.t_enum_status_thorns = 9;
		全局.t_enum_disable_button = 10;

		全局.args_system[0] = 地图工坊设置整数(自定义字符串("系统"), 自定义字符串("资源回收间隔（ms）"), 10, 1, 1000, 0) * 0.001;

		全局.args_tracer[0] = 地图工坊设置整数(自定义字符串("猎空"), 自定义字符串("最大能量"), 50, 1, 200, 0);
		全局.args_tracer[1] = 地图工坊设置整数(自定义字符串("猎空"), 自定义字符串("伤害池大小"), 150, 1, 500, 0);
		全局.args_tracer[2] = 地图工坊设置实数(自定义字符串("猎空"), 自定义字符串("伤害池伤害百分比"), 1, 1, 100, 0) * 0.01;
		全局.args_tracer[3] = 地图工坊设置组合(自定义字符串("猎空"), 自定义字符串("伤害池计算方式"), 0, 数组(自定义字符串("最大生命值"), 自定义字符串("当前生命值"), 自定义字符串("已损生命值")), 0);
		全局.args_tracer[4] = 地图工坊设置整数(自定义字符串("猎空"), 自定义字符串("伤害池单发最大伤害"), 20, 1, 100, 0);

		全局.args_zenyata[0] = 地图工坊设置整数(自定义字符串("禅雅塔"), 自定义字符串("破-攻击间隔"), 2, 2, 5, 0);
		全局.args_zenyata[1] = 地图工坊设置整数(自定义字符串("禅雅塔"), 自定义字符串("圣-额外治疗"), 100, 0, 500, 0);

		全局.args_reaper[0] = 地图工坊设置实数(自定义字符串("死神"), 自定义字符串("幽灵形态-持续时间"), 2.5, 0.5, 10.0, 0);
		全局.args_reaper[1] = 地图工坊设置实数(自定义字符串("死神"), 自定义字符串("幽灵形态-冷却时间"), 15.0, 5.0, 30.0, 0);
		全局.args_reaper[2] = 地图工坊设置实数(自定义字符串("死神"), 自定义字符串("幽灵形态-速度加成"), 50.0, 0.0, 100.0, 0);
		全局.args_reaper[3] = 地图工坊设置实数(自定义字符串("死神"), 自定义字符串("幽灵形态-减伤比例"), 20.0, 0.0, 100.0, 0);
		全局.args_reaper[4] = 地图工坊设置整数(自定义字符串("死神"), 自定义字符串("恐惧-子弹伤害"), 40.0, 0.0, 100.0, 0);
		全局.args_reaper[5] = 地图工坊设置整数(自定义字符串("死神"), 自定义字符串("恐惧-子弹大小"), 10.0, 0.0, 100.0, 0) * 0.01;
		全局.args_reaper[6] = 地图工坊设置整数(自定义字符串("死神"), 自定义字符串("恐惧-弹道速度"), 750, 100, 1000, 0);
		全局.args_reaper[7] = 地图工坊设置整数(自定义字符串("死神"), 自定义字符串("恐惧-持续时间（ms）"), 20, 1, 100, 0) * 0.001;

		全局.cd_lucio_cd_dec = 0.100;
		全局.ci_mei_shift_heal = 40;
		全局.ci_mei_shift_heal_time = 0.1;

		全局.args_ana[0] = 地图工坊设置整数(自定义字符串("安娜"), 自定义字符串("群体激素-增伤比例"), 30, 0, 100, 0);
		全局.args_ana[1] = 地图工坊设置整数(自定义字符串("安娜"), 自定义字符串("群体激素-减伤比例"), 30, 0, 100, 1);
		全局.args_ana[2] = 地图工坊设置整数(自定义字符串("安娜"), 自定义字符串("群体激素-加速比例"), 10, 0, 100, 2);

		全局.args_ramattra[0] = 地图工坊设置整数(自定义字符串("拉玛刹"), 自定义字符串("伤害吸收比例-天罚形态"), 30, 0, 100, 0);
		全局.args_ramattra[1] = 地图工坊设置整数(自定义字符串("拉玛刹"), 自定义字符串("伤害吸收比例-诛"), 60, 0, 100, 1);
		全局.args_ramattra[2] = 地图工坊设置实数(自定义字符串("拉玛刹"), 自定义字符串("伤害吸收-治疗时间"), 0.1, 0.1, 1.0, 2);

		全局.args_junkerqueen[0] = 地图工坊设置整数(自定义字符串("渣客女王"), 自定义字符串("创伤-伤害降低效果"), 15, 0, 100, 0);
		全局.args_junkerqueen[1] = 地图工坊设置整数(自定义字符串("渣客女王"), 自定义字符串("创伤-治疗降低效果"), 15, 0, 100, 1);
		全局.args_junkerqueen[2] = 地图工坊设置整数(自定义字符串("渣客女王"), 自定义字符串("荆棘效果-命令怒吼"), 25, 0, 100, 2) * 0.01;
		全局.args_junkerqueen[3] = 地图工坊设置整数(自定义字符串("渣客女王"), 自定义字符串("荆棘效果-血斩"), 25, 0, 100, 3) * 0.01;
		全局.args_junkerqueen[4] = 地图工坊设置整数(自定义字符串("渣客女王"), 自定义字符串("荆棘效果-轰翻天"), 25, 0, 100, 4) * 0.01;
		全局.args_junkerqueen[5] = 地图工坊设置整数(自定义字符串("渣客女王"), 自定义字符串("基础护甲"), 105, 0, 500, 5);

		全局.ch_normal_attack_dist = 数组(数组(英雄(拉玛刹), 按钮(技能1)), 数组(英雄(拉玛刹), 按钮(终极技能)), 数组(英雄(半藏), 按钮(技能1)), 数组(英雄(半藏), 按钮(技能2)), 数组(英雄(源氏), 按钮(终极技能)));
		全局.ca_zenyata_armor_heros = 数组(英雄(伊拉锐), 英雄(半藏), 英雄(卡西迪), 英雄(卢西奥), 英雄(回声), 英雄(士兵：76), 英雄(天使), 英雄(安娜), 英雄(巴蒂斯特), 英雄(探奇), 英雄(末日铁拳), 英雄(朱诺), 英雄(查莉娅), 英雄(死神), 英雄(法老之鹰), 英雄(源氏), 英雄(狂鼠), 英雄(猎空), 英雄(生命之梭), 英雄(禅雅塔), 英雄(秩序之光), 英雄(索杰恩), 英雄(美), 英雄(艾什), 英雄(莫伊拉), 英雄(西格玛), 英雄(路霸), 英雄(雾子), 英雄(黑影), 英雄(黑百合));
	}
}

禁用 规则("随机数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		While(真);
			全局.random = 随机实数(0, 1);
			等待(0, 无视条件);
		End;
	}
}

规则("回合之间释放资源")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		处于回合之间 == 真;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 数组(当前数组元素[0], 当前数组元素[1]));
	}
}

规则("资源回收执行")
{
	事件
	{
		子程序;
		remove_default_status;
	}

	动作
	{
		If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_hp_pool && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1] > 0);
			移除玩家的生命池(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_damage_adjust && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1] > 0);
			停止伤害调整(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_heal_adjust && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1] > 0);
			停止治疗调整(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_effect && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1] > 0);
			消除效果(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_speed);
			事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0].i_sys_speed -= 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1];
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_move_cd);
			事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0].d_sys_cd -= 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1];
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_map_text && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1] > 0);
			消除地图文本(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_status_thorns);
			事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0].d_sys_status_thorns -= 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1];
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_assists && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1] > 0);
			停止助攻(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_disable_button);
			可用按钮(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0], 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1]);
		End;
		事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i] = 空;
	}
}

规则("系统资源回收")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待直到 (数量(事件玩家.sys_default_status_pool) > 0, 99999);
			等待(全局.args_system[0], 无视条件);
			For 玩家变量(事件玩家, sys_default_status_pool_i, 数量(事件玩家.sys_default_status_pool) - 1, -1, -1);
				If(数量(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i]) == 2);
					调用子程序(remove_default_status);
				Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][4] == 空 || 所用英雄(事件玩家)
						== 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][4]);
					If(
						事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][2] >= 0 && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][3] >= 0 && 总计消耗时间 - 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][2] > 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][3]);
						调用子程序(remove_default_status);
					End;
				Else;
					调用子程序(remove_default_status);
				End;
			End;
			事件玩家.sys_default_status_pool = 已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素 != 空 && 数量(当前数组元素) > 1);
		End;
	}
}

规则("全局定时器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			If(事件玩家.junkerqueen_timer > 0);
				事件玩家.junkerqueen_timer -= 0.100;
			Else;
				事件玩家.junkerqueen_timer = 0;
			End;
			If(事件玩家.widowmaker_hp_pool_timer > 0);
				事件玩家.widowmaker_hp_pool_timer -= 0.100;
			Else;
				事件玩家.widowmaker_hp_pool_timer = 0;
			End;
			If(事件玩家.reinhardt_shield != 空 && 事件玩家.reinhardt_shield[0] > 0);
				事件玩家.reinhardt_shield[0] -= 0.100;
			End;
			等待(0.100, 无视条件);
		End;
	}
}

规则("个人文本烂")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待(0.500, 无视条件);
			If(事件玩家.sys_self_text != 空 && 所用英雄(事件玩家) != 事件玩家.sys_self_text[0]);
				消除HUD文本(事件玩家.sys_self_text[1]);
				事件玩家.sys_self_text = 空;
			End;
		End;
	}
}

规则("个人数据面板")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.sys_data_record == 空 || 数量(事件玩家.sys_data_record) <= 0 || 所用英雄(事件玩家) != 事件玩家.sys_data_record[0]) == 真;
	}

	动作
	{
		事件玩家.sys_data_record = 数组(所用英雄(事件玩家));
	}
}

规则("目标点减伤")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		开始伤害调整(所有目标点外玩家(队伍1), 所有目标点内玩家(队伍2), 80, 受伤害者，伤害者及伤害百分比);
		开始伤害调整(所有目标点外玩家(队伍2), 所有目标点内玩家(队伍1), 80, 受伤害者，伤害者及伤害百分比);
	}
}

规则("易伤清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		具有状态(事件玩家, 相移) == 真;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 字符串包含(当前数组元素[5], 自定义字符串("Vulnerable")) ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("sys_speed")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待直到 (事件玩家.i_sys_pre_speed != 事件玩家.i_sys_speed, 9999);
			设置移动速度(事件玩家, 100 + 事件玩家.i_sys_speed);
			事件玩家.i_sys_pre_speed = 事件玩家.i_sys_speed;
		End;
	}
}

规则("系统-助攻")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待直到(玩家数据(事件玩家, 消灭) != 事件玩家.i_sys_assists, 99999);
			事件玩家.i_sys_assists = 玩家数据(事件玩家, 消灭);
		End;
	}
}

规则("系统-技能冷却-S")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(技能1)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(技能1)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(技能1), 技能冷却时间(事件玩家, 按钮(技能1)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(技能2)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(技能2), 技能冷却时间(事件玩家, 按钮(技能2)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-主武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(主要攻击模式)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(主要攻击模式)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(主要攻击模式), 技能冷却时间(事件玩家, 按钮(主要攻击模式)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(辅助攻击模式), 技能冷却时间(事件玩家, 按钮(辅助攻击模式)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-跳跃")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(跳跃)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(跳跃)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(跳跃), 技能冷却时间(事件玩家, 按钮(跳跃)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-终极技能效率")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.a_sys_ultimate_efficiency == 空 || 数量(事件玩家.a_sys_ultimate_efficiency) <= 0) == 真;
	}

	动作
	{
		事件玩家.a_sys_ultimate_efficiency = 数组(-1, 0, 0);
	}
}

规则("系统-终极技能效率")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在人格复制(事件玩家) != 真;
		终极技能充能百分比(事件玩家) != 100;
		正在使用终极技能(事件玩家) != 真;
		数量(事件玩家.a_sys_ultimate_efficiency) > 0;
		事件玩家.a_sys_ultimate_efficiency[0] == -1;
	}

	动作
	{
		事件玩家.a_sys_ultimate_efficiency[0] = 总计消耗时间;
	}
}

规则("系统-终极技能效率")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在人格复制(事件玩家) != 真;
		(终极技能充能百分比(事件玩家) == 100 || 正在使用终极技能(事件玩家)) == 真;
		数量(事件玩家.a_sys_ultimate_efficiency) > 0;
		事件玩家.a_sys_ultimate_efficiency[0] > 0;
	}

	动作
	{
		事件玩家.a_sys_ultimate_efficiency = 数组(-1, 事件玩家.a_sys_ultimate_efficiency[1]+(总计消耗时间-事件玩家.a_sys_ultimate_efficiency[0]), 事件玩家.a_sys_ultimate_efficiency[2]+1);
		等待(10.0, 无视条件);
	}
}

规则("系统-终极技能效率")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 自定义字符串(""), 自定义字符串("{0}: {1}s, {2}", 事件玩家, 事件玩家.a_sys_ultimate_efficiency[1]/事件玩家.a_sys_ultimate_efficiency[2], 玩家数据(事件玩家, 阻挡伤害量)), 自定义字符串(""), 左边, 栏位(事件玩家), 颜色(白色), 颜色(白色), 颜色(白色), 可见性，排序规则和字符串, 默认可见度);
	}
}

规则("状态显示文本")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		创建HUD文本(事件玩家.d_sys_status_thorns > 0 ? 事件玩家 : 空, 自定义字符串(""), 自定义字符串("荆棘：{0}%", 事件玩家.d_sys_status_thorns * 100.0), 自定义字符串(""), 右边, 0, 颜色(白色), 颜色(绿色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("系统-状态-荆棘")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		攻击方.d_sys_status_thorns > 0.0;
		事件技能 != 空;
	}

	动作
	{
		伤害(攻击方, 被攻击方, 较小(被攻击方.d_sys_status_thorns, 1.0) * 事件伤害);
	}
}

规则("系统-状态-荆棘")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		攻击方.d_sys_status_thorns <= 0.0;
	}

	动作
	{
		伤害(攻击方, 被攻击方, 较小(被攻击方.d_sys_status_thorns, 1.0) * 事件伤害);
	}
}

规则("艾什-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, 爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, 爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 40, 0.250, 5, 有害爆炸, 爆炸声音, 0, 40, 60, 0.300, 0, 15);
	}
}

规则("美-shift")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(美);
		正在使用技能 1(事件玩家) == 真;
		事件玩家.mei_s_begin_time == 空;
	}

	动作
	{
		事件玩家.mei_s_begin_time = 总计消耗时间;
		While(所用英雄(事件玩家) == 英雄(美) && 存活(事件玩家) && 总计消耗时间 - 事件玩家.mei_s_begin_time < 5.0);
			范围内玩家(眼睛位置(事件玩家), 8.5, 所在队伍(事件玩家), 关闭).mei_s_flag = 事件玩家;
			等待(1.0, 无视条件);
		End;
		等待直到(!(正在使用技能 1(事件玩家) == 真 && 所用英雄(事件玩家) == 英雄(美)), 99999);
		事件玩家.mei_s_begin_time = 空;
	}
}

规则("美-shift-过度治疗")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.mei_s_flag != 空;
		存活(事件玩家.mei_s_flag) == 真;
		事件玩家.mei_Q_timer == 空;
	}

	动作
	{
		If(事件玩家 != 事件玩家.mei_s_flag);
			开始持续治疗(事件玩家, 事件玩家.mei_s_flag, 全局.ci_mei_shift_heal_time, 全局.ci_mei_shift_heal / 全局.ci_mei_shift_heal_time);
			事件玩家.mei_Q_timer = 数组(总计消耗时间, 生命值(事件玩家), 上一个持续治疗效果ID, 空);

			等待直到(标准化生命值(事件玩家) >= 1.0, 全局.ci_mei_shift_heal_time);
			停止持续治疗(事件玩家.mei_Q_timer[2]);

			If(总计消耗时间 - 事件玩家.mei_Q_timer[0] < 全局.ci_mei_shift_heal_time && 标准化生命值(事件玩家) >= 1.0 && 最大生命值(事件玩家) - 事件玩家.mei_Q_timer[1] < 全局.ci_mei_shift_heal);
				If(事件玩家.mei_Q_dec != 空);
					移除玩家的生命池(事件玩家.mei_Q_dec);
				End;

				为玩家添加生命池(事件玩家, 生命值, 较小(全局.ci_mei_shift_heal - (最大生命值(事件玩家) - 事件玩家.mei_Q_timer[1]), 全局.ci_mei_shift_heal), 假, 假);
				事件玩家.mei_Q_dec = 最后创建的生命池;
				事件玩家.mei_s_flag.sys_default_status_pool[数量(事件玩家.mei_s_flag.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 事件玩家.mei_Q_dec, 总计消耗时间, 3.00, 英雄(美));
			End;

		End;

		事件玩家.mei_Q_timer = 空;
		事件玩家.mei_s_flag = 空;
	}
}

规则("猎空-能量")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("剩余能量：{0} - 剩余伤害：{1}", 较大(0, 全局.args_tracer[0] - 事件玩家.tracer_energy), 较大(0,
			全局.args_tracer[1] - 事件玩家.tracer_hit)), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("猎空-左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
		事件玩家.tracer_energy < 全局.args_tracer[0];
		事件玩家.tracer_energy_reset == 0;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真 && 事件玩家.tracer_energy < 全局.args_tracer[0]);
			事件玩家.tracer_energy += 1;
			等待(0.050, 无视条件);
		End;
	}
}

规则("猎空-左键-冷却")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) != 真;
		事件玩家.tracer_energy < 全局.args_tracer[0];
		事件玩家.tracer_energy_reset == 0;
		(事件玩家.tracer_energy > 0 || 事件玩家.tracer_hit > 0) == 真;
	}

	动作
	{
		等待直到 (正在使用主要武器(事件玩家), 3);
		While(正在使用主要武器(事件玩家) != 真 && 事件玩家.tracer_energy < 全局.args_tracer[0] && (事件玩家.tracer_energy > 0 || 事件玩家.tracer_hit > 0));
			事件玩家.tracer_energy = 较大(0, 事件玩家.tracer_energy - 1);
			事件玩家.tracer_hit = 较大(0, 事件玩家.tracer_hit - 5);
			等待(0.200, 无视条件);
		End;
	}
}

规则("猎空-左键-过热")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy >= 全局.args_tracer[0];
	}

	动作
	{
		设置弹药(事件玩家, 0, 0);
		事件玩家.tracer_energy_reset = 总计消耗时间;
		While(
			事件玩家.tracer_energy >= 全局.args_tracer[0] && 事件玩家.tracer_energy_reset != 0 && 总计消耗时间 - 事件玩家.tracer_energy_reset <= 0.900);
			等待(0.300, 无视条件);
			设置弹药(事件玩家, 0, 0);
		End;
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
		事件玩家.tracer_energy_reset = 0;
	}
}

规则("猎空-记录")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	动作
	{
		While(所用英雄(事件玩家) == 英雄(猎空));
			等待(3, 当为“假”时中止);
			事件玩家.tracer_energy_last = 事件玩家.tracer_energy;
			事件玩家.tracer_hit_last = 事件玩家.tracer_hit;
		End;
	}
}

规则("猎空-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 较小(事件玩家.tracer_energy, 事件玩家.tracer_energy_last);
	}
}

规则("猎空-左键-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		猎空;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		事件玩家.tracer_hit < 全局.args_tracer[1];
	}

	动作
	{
		伤害(被攻击方, 攻击方, 较小(全局.args_tracer[4], 最大生命值(被攻击方) * 全局.args_tracer[2]));
		If((具有状态(被攻击方, 沉睡) || 具有状态(被攻击方, 冰冻) || 具有状态(被攻击方, 击倒) || 具有状态(被攻击方, 击晕) || 具有状态(被攻击方, 被入侵)) == 真);
			中止;
		End;
		事件玩家.tracer_hit = 较小(全局.args_tracer[1], 事件玩家.tracer_hit + 较小(全局.args_tracer[4], 最大生命值(被攻击方) * 全局.args_tracer[2]));
	}
}

规则("猎空-换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家.tracer_energy + 事件玩家.tracer_hit > 0;
	}

	动作
	{
		事件玩家.tracer_energy = 999;
		事件玩家.tracer_hit = 999;
	}
}

规则("猎空-重生")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		在重生室中(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
	}
}

规则("猎空-刷新")
{
	事件
	{
		玩家参与消灭;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(猎空);
	}

	动作
	{
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
	}
}

规则("源氏-S")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(源氏);
		事件技能 == 按钮(技能1);
	}

	动作
	{
		为玩家添加生命池(攻击方, 生命值, 10, 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3.00, 英雄(源氏));
	}
}

规则("源氏-S")
{
	事件
	{
		玩家参与消灭;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(源氏);
	}

	动作
	{
		为玩家添加生命池(攻击方, 生命值, 10, 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3.00, 英雄(源氏));
	}
}

规则("源氏-增伤")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 护甲, 100, 真, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 10, 英雄(源氏), 自定义字符串(
			"Genji Dragonblade hp pool"));
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家, 150, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 6, 英雄(源氏), 自定义字符串(
			"Genji Dragonblade adjust"));
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 50, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 6, 英雄(源氏), 自定义字符串(
			"Genji Dragonblade adjust"));
		等待直到 (正在使用终极技能(事件玩家) != 真, 10);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Genji Dragonblade adjust") ? 数组分割(当前数组元素,
			0, 2) : 当前数组元素);
		等待(4, 无视条件);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Genji Dragonblade hp pool") ? 数组分割(当前数组元素,
			0, 2) : 当前数组元素);
	}
}

规则("源氏-E-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 护甲, 50, 真, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(源氏));
	}
}

规则("破坏球-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		破坏球;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.wrecking_ball_players = 范围内玩家(事件玩家, 8, 所在队伍(事件玩家), 表面及敌方屏障);
		开始伤害调整(事件玩家.wrecking_ball_players, 所有玩家(所在队伍(事件玩家)), 60, 无);
		事件玩家.wrecking_ball_dec_id = 上一个伤害调整ID;
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 事件玩家;
		等待(5, 无视条件);
		停止伤害调整(事件玩家.wrecking_ball_dec_id);
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 0;
	}
}

规则("破坏球-减伤")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件玩家.wrecking_ball_dec != 0;
		攻击方 != 空;
	}

	动作
	{
		伤害(事件玩家.wrecking_ball_dec, 攻击方, 事件伤害 * 0.500);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(白色), 事件玩家, 1);
	}
}

规则("布丽吉塔-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.buligita_players = 范围内玩家(眼睛位置(事件玩家), 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
		设置状态(事件玩家.buligita_players, 事件玩家, 无敌, 0.250);

		开始伤害调整(事件玩家.buligita_players, 所有玩家(所有队伍), 80, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 11, 英雄(布丽吉塔),
			自定义字符串("Brigitte Rally"));

		创建效果(所有玩家(所有队伍), 火花, 颜色(黄色), 事件玩家, 8.5, 位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 11, 英雄(布丽吉塔), 自定义字符串(
			"Brigitte Rally"));

		While(正在使用终极技能(事件玩家) == 真);
			事件玩家.buligita_players = 范围内玩家(眼睛位置(事件玩家), 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
			事件玩家.buligita_players.i_sys_speed += 20;
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家.buligita_players, 20), 总计消耗时间, 1.00,
				英雄(布丽吉塔), 自定义字符串("Brigitte Rally"));
			等待直到 (正在使用终极技能(事件玩家) != 真, 1.00);
			等待直到 (!对任意为“真”(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Rally") && 当前数组元素[0] == 全局.t_enum_speed), 1.00);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Rally") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		事件玩家.buligita_players = 空;
	}
}

规则("布丽吉塔-护甲包")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		事件技能 == 按钮(技能2);
		所用英雄(治疗者) == 英雄(布丽吉塔);
		数量((已过滤的数组(受治疗者.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Repair Pack Overheal")))) <= 0;
	}

	动作
	{
		等待直到(标准化生命值(受治疗者) >= 1.0, 2.0);
		等待(0.1, 无视条件);
		为玩家添加生命池(受治疗者, 护甲, 5, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 空, 自定义字符串("Brigitte Repair Pack Overheal"));
		等待(0.1, 无视条件);
		为玩家添加生命池(受治疗者, 护甲, 5, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 空, 自定义字符串("Brigitte Repair Pack Overheal"));
		等待(0.1, 无视条件);
		为玩家添加生命池(受治疗者, 护甲, 5, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 空, 自定义字符串("Brigitte Repair Pack Overheal"));
		等待(0.1, 无视条件);
		为玩家添加生命池(受治疗者, 护甲, 5, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 空, 自定义字符串("Brigitte Repair Pack Overheal"));
		等待(0.1, 无视条件);
		为玩家添加生命池(受治疗者, 护甲, 5, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 空, 自定义字符串("Brigitte Repair Pack Overheal"));
		等待(0.1, 无视条件);
		为玩家添加生命池(受治疗者, 护甲, 5, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 空, 自定义字符串("Brigitte Repair Pack Overheal"));
		等待(1.4, 无视条件);
	}
}


规则("奥丽莎-S-金甲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		奥丽莎;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障).orisa_teammates = 1;
	}
}

规则("奥丽莎-Q-金甲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		奥丽莎;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		While(正在使用终极技能(事件玩家));
			范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障).orisa_teammates = 1;
			等待直到(!正在使用终极技能(事件玩家), 1.50);
		End;
	}
}

规则("奥丽莎-金甲创建")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.orisa_teammates > 0;
	}

	动作
	{
		事件玩家.orisa_master += 事件玩家.orisa_teammates;
		事件玩家.orisa_teammates = 0;

		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 0.5, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 6, 空, 自定义字符串(
			"Orisa Terra Surge"));

		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 事件玩家, 1.5, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 6, 空, 自定义字符串(
			"Orisa Terra Surge"));
	}
}

规则("奥丽莎-金甲效果")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		被攻击方.orisa_master > 0;
	}

	动作
	{
		被攻击方.orisa_master -= 1;
		等待(0.02, 无视条件);
	}
}

规则("奥丽莎-金甲消失")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.orisa_master <= 0;
	}

	动作
	{
		事件玩家.orisa_master = 0;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Orisa Terra Surge") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
	}
}

规则("奥丽莎-金甲消失")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.orisa_master > 0;
		数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Orisa Terra Surge"))) <= 0;
	}

	动作
	{
		事件玩家.orisa_master = 0;
	}
}

规则("卢西奥-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		范围内玩家(事件玩家, 30, 所在队伍(事件玩家), 表面及敌方屏障).lucio_debuff_clear = 真;

		等待直到(!正在使用技能 2(事件玩家), 5.0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
	}
}

规则("卢西奥-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(卢西奥);
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置引力(事件玩家, 999);
		等待直到(在地面上(事件玩家) || !存活(事件玩家) || 所用英雄(事件玩家) != 英雄(卢西奥), 99999);
		设置引力(事件玩家, 100);
	}
}

规则("卢西奥-Q-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
	}

	动作
	{
		等待(6, 无视条件);
		事件玩家.lucio_debuff_clear = 假;
	}
}

规则("卢西奥-Q-负面状态清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
		(具有状态(事件玩家, 冰冻) || 具有状态(事件玩家, 击倒) || 具有状态(事件玩家, 击晕) || 具有状态(事件玩家, 沉睡) || 具有状态(事件玩家, 燃烧) || 具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 定身)) == 真;
		(所用英雄(事件玩家) == 英雄(安娜) && 正在使用终极技能(事件玩家)) != 真;
	}

	动作
	{
		While(事件玩家.lucio_debuff_clear == 真 && (具有状态(事件玩家, 冰冻) || 具有状态(事件玩家, 击倒) || 具有状态(事件玩家, 击晕) || 具有状态(事件玩家, 沉睡) || 具有状态(事件玩家, 燃烧) || 具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 定身)));
			清除状态(事件玩家, 冰冻);
			清除状态(事件玩家, 沉睡);
			清除状态(事件玩家, 燃烧);
			清除状态(事件玩家, 击倒);
			清除状态(事件玩家, 击晕);
			清除状态(事件玩家, 被入侵);
			清除状态(事件玩家, 定身);
			等待(0.100, 无视条件);
		End;
	}
}

规则("卢西奥-被动-滑墙")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		在墙上(事件玩家) == 真;
		在地面上(事件玩家) != 真;
	}

	动作
	{
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 90, 受伤害者和伤害者);
		事件玩家.lucio_slice_dec = 上一个伤害调整ID;
	}
}

规则("卢西奥-被动-冷静光环")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		存活(事件玩家) == 真;
		正在使用技能 1(事件玩家) != 真;
	}

	动作
	{
		While(存活(事件玩家) && !正在使用技能 1(事件玩家));
			事件玩家.lucio_players = 范围内玩家(眼睛位置(事件玩家), 12, 所在队伍(事件玩家), 表面及敌方屏障);

			事件玩家.lucio_players.d_sys_cd += 全局.cd_lucio_cd_dec;
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_move_cd, 数组(事件玩家.lucio_players, 全局.cd_lucio_cd_dec),
				总计消耗时间, 1.0, 英雄(卢西奥), 自定义字符串("Lucio Crossfade"));

			If(正在使用技能 2(事件玩家) == 真);
				开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家.lucio_players, 130, 受伤害者，伤害者及伤害百分比);
				事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 1.00, 英雄(卢西奥), 自定义字符串(
					"Lucio Crossfade"));
				事件玩家.lucio_players.i_sys_speed += 60;
				事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家.lucio_players, 60), 总计消耗时间, 1.00,
					英雄(卢西奥), 自定义字符串("Lucio Crossfade"));
			Else;
				事件玩家.lucio_players.i_sys_speed += 25;
				事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家.lucio_players, 25), 总计消耗时间, 1.00,
					英雄(卢西奥), 自定义字符串("Lucio Crossfade"));
			End;

			等待(1.0, 无视条件);
			等待直到 (!对任意为“真”(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Lucio Crossfade")), 1.00);
		End;
	}
}

规则("卢西奥-光环一体")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(卢西奥);
		存活(事件玩家) == 真;
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		While(正在使用技能 1(事件玩家) == 真);
			设置启用技能 1(事件玩家, 真);
			开始按下按钮(事件玩家, 按钮(技能1));
			等待直到(正在使用技能 1(事件玩家) != 真, 0.5);
		End;

		等待直到(所用英雄(事件玩家) != 英雄(卢西奥) || !存活(事件玩家) || 正在使用技能 1(事件玩家) == 真, 99999);
		停止按下按钮(事件玩家, 按钮(技能1));
		设置启用技能 1(事件玩家, 真);
	}
}

规则("卢西奥-光环一体")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(卢西奥);
		存活(事件玩家) == 真;
		正在使用技能 1(事件玩家) != 真;
	}

	动作
	{
		设置启用技能 1(事件玩家, 假);
	}
}

规则("卢西奥-被动-滑墙-解除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_slice_dec != 空;
		(所用英雄(事件玩家) != 英雄(卢西奥) || 在墙上(事件玩家) != 真 || 在地面上(事件玩家)) == 真;
	}

	动作
	{
		停止伤害调整(事件玩家.lucio_slice_dec);
		事件玩家.lucio_slice_dec = 0;
	}
}

规则("黑影-伤害")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(黑影);
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(主要攻击模式)) == 真;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		If(事件玩家.sombra_player == 空);
			事件玩家.sombra_player = 攻击方;
			事件玩家.sombra_demage = 事件伤害;
			事件玩家.sombra_timer = 3;
		Else If(事件玩家.sombra_player == 攻击方);
			事件玩家.sombra_demage += 事件伤害;
			事件玩家.sombra_timer = 3;
		Else;
			中止;
		End;
		If(事件玩家.sombra_demage > 最大生命值(事件玩家) * 0.400);
			设置状态(事件玩家, 事件玩家.sombra_player, 被入侵, 3);
			事件玩家.sombra_hacked = 真;
			事件玩家.sombra_timer = 0;
			事件玩家.sombra_player = 空;
			事件玩家.sombra_demage = 0;
			等待(7, 无视条件);
			事件玩家.sombra_hacked = 假;
		End;
	}
}

规则("黑影-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sombra_player != 空;
		事件玩家.sombra_demage > 0;
		事件玩家.sombra_timer > 0;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		While(事件玩家.sombra_timer > 0);
			等待直到 (事件玩家.sombra_timer <= 0, 1);
			事件玩家.sombra_timer -= 1;
		End;
		事件玩家.sombra_player = 空;
		事件玩家.sombra_demage = 0;
	}
}

规则("布丽吉塔-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用辅助武器(事件玩家) != 真, 1.500);
		创建效果(所有玩家(所有队伍), 环, 自定义颜色(248, 213, 97, 171), 事件玩家, 10, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, -1, 英雄(布丽吉塔), 自定义字符串(
			"Brigitte Barrier Shield"));
		While(正在使用辅助武器(事件玩家) == 真);
			开始持续治疗(范围内玩家(眼睛位置(事件玩家), 15, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家, 0.500, 10);
			等待直到 (正在使用辅助武器(事件玩家) != 真, 0.500);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Barrier Shield") ? 数组分割(当前数组元素, 0,
			2) : 当前数组元素);
	}
}

规则("布丽吉塔-副武器-盾击")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		(所用英雄(攻击方) == 英雄(布丽吉塔) || 正在复制的英雄(攻击方) == 英雄(布丽吉塔)) == 真;
		事件技能 == 按钮(主要攻击模式);
		正在使用辅助武器(攻击方) == 真;
		正在使用终极技能(攻击方) != 真;
	}

	动作
	{
		设置状态(被攻击方, 攻击方, 击晕, 0.500);
	}
}

规则("布丽吉塔-s-护甲链枷")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		(所用英雄(攻击方) == 英雄(布丽吉塔) || 正在复制的英雄(攻击方) == 英雄(布丽吉塔)) == 真;
		事件技能 == 按钮(技能1);
	}

	动作
	{
		为玩家添加生命池(范围内玩家(眼睛位置(攻击方), 8.500, 所在队伍(攻击方), 表面及敌方屏障), 生命值, 最大生命值(被攻击方) * 0.15, 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(布丽吉塔), 自定义字符串(
			"Brigitte Shift"));
	}
}

规则("死神-被动-暗影")
{
	事件
	{
		玩家受到伤害;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) != 真;
	}

	动作
	{
		If(随机实数(0, 1) <= 0.05);
			设置状态(事件玩家, 事件玩家, 相移, 0.250);
			等待(0.250, 无视条件);
		End;
	}
}

禁用 规则("死神-主武器-坦克杀手")
{
	事件
	{
		玩家造成伤害;
		双方;
		死神;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		数组包含(所有重装英雄, 所用英雄(被攻击方)) == 真;
	}

	动作
	{
		If(类型的生命值(被攻击方, 护甲) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.300);
		Else If(类型的生命值(被攻击方, 护盾) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.200);
		Else;
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.100);
		End;
	}
}

规则("死神-主武器-恐惧")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(死神);
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		创建弹道(“路霸”爆裂枪废铁球, 事件玩家, 空, 空, 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 全局.args_reaper[4], 2, 0, 有益爆炸, 爆炸声音, 全局.args_reaper[5], 全局.args_reaper[6], 全局.args_reaper[7], 0, 0, 0);
	}
}

规则("死神-暗影步-禁用")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		// 数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Reaper Wraith Form Disable"))) <= 0;
		数量(事件玩家.sys_default_status_pool) <= 0;
	}

	动作
	{
		// 事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Reaper Wraith Form Disable") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
		// 等待直到(数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Reaper Wraith Form Disable"))) <= 0, 99999);

		禁用按钮(事件玩家, 按钮(技能1));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_disable_button, 数组(事件玩家, 按钮(技能1)), 总计消耗时间, -1, 英雄(死神), 自定义字符串(
			"Reaper Wraith Form Disable"));
	}
}

规则("死神-暗影步")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(死神);
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		技能冷却时间(事件玩家, 按钮(技能1)) <= 0;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(技能1), 全局.args_reaper[1]);
		设置状态(事件玩家, 事件玩家, 相移, 0.5);

		事件玩家.i_sys_speed += 全局.args_reaper[2];
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 全局.args_reaper[2]), 总计消耗时间, 全局.args_reaper[0], 英雄(死神), 自定义字符串("Reaper Wraith Form"));

		开始伤害调整(事件玩家, 所有玩家(所有队伍), 100 - 全局.args_reaper[3], 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 全局.args_reaper[0], 英雄(死神), 自定义字符串("Reaper Wraith Form"));

		设置弹药(事件玩家, 0, 最大弹药(事件玩家, 0));

		创建效果(所有玩家(所有队伍), “死神”幽灵形态效果, 颜色(黑色), 事件玩家, 0, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 全局.args_reaper[0], 英雄(死神), 自定义字符串("Reaper Wraith Form"));

		创建效果(所有玩家(所有队伍), 美冰冻效果, 颜色(黑色), 事件玩家, 0, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 全局.args_reaper[0], 英雄(死神), 自定义字符串("Reaper Wraith Form"));

		创建效果(所有玩家(所有队伍), “破坏球”感应护盾目标效果, 颜色(黑色), 事件玩家, 0, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 全局.args_reaper[0], 英雄(死神), 自定义字符串("Reaper Wraith Form"));
	}
}

规则("死神-暗影-特效")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) == 真;
	}

	动作
	{
		创建效果(具有状态(事件玩家, 相移) ? 所有玩家(所有队伍) : 空, 云, 颜色(紫色), 事件玩家, 1.500, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, -1, 英雄(死神), 自定义字符串("Reaper Shadow"));
	}
}

规则("死神-终极技能-高速绽放")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.i_sys_speed += 150;
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 100), 总计消耗时间, 1, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 20), 总计消耗时间, 1.500, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 10), 总计消耗时间, 2, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 10), 总计消耗时间, 2.500, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 10), 总计消耗时间, 3, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
	}
}

规则("DVA-被暴击")
{
	事件
	{
		玩家受到伤害;
		双方;
		D.Va;
	}

	条件
	{
		事件暴击 == 真;
		处于非初始状态(事件玩家) != 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 较大(事件伤害 * 0.500, 10) * (事件暴击 ? 1 : 0.300), 假, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.500, 英雄(D.Va));
	}
}

规则("DVA-被动-飞行矩阵回复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		While(正在使用技能 1(事件玩家) == 真);
			设置技能资源(事件玩家, 按钮(辅助攻击模式), 3 + 技能资源(事件玩家, 按钮(辅助攻击模式)));
			等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		End;
	}
}

规则("DVA-被动-护甲回复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		事件玩家.dva_armor_recover == 空;
		正在使用辅助武器(事件玩家) == 真;
		处于非初始状态(事件玩家) != 真;
	}

	动作
	{
		开始持续治疗(事件玩家, 事件玩家, 9999999.000, 30);
		事件玩家.dva_armor_recover = 上一个持续治疗效果ID;
	}
}

规则("DVA-被动-护甲回复-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.dva_armor_recover != 空;
		(英雄(D.Va) != 所用英雄(事件玩家) || 处于非初始状态(事件玩家) || 正在使用辅助武器(事件玩家) != 真) == 真;
	}

	动作
	{
		停止持续治疗(事件玩家.dva_armor_recover);
		事件玩家.dva_armor_recover = 空;
	}
}

规则("巴蒂斯特-S-临时生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, (最大生命值(事件玩家) - 生命值(事件玩家)) * 0.400, 假, 假);
		事件玩家.baptiste_shift_hp = 最后创建的生命池;
		事件玩家.sys_data_record[1] += (最大生命值(事件玩家) - 生命值(事件玩家)) * 0.400;
		等待(3, 无视条件);
		移除玩家的生命池(事件玩家.baptiste_shift_hp);
	}
}

规则("巴蒂斯特-主武器-附加伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		巴蒂斯特;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		伤害(被攻击方, 攻击方, 生命值(被攻击方) * 0.040);
	}
}

规则("巴蒂斯特-副武器-弹匣大小")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	动作
	{
		设置最大弹药(事件玩家, 1, 14);
		设置弹药(事件玩家, 1, 最大弹药(事件玩家, 1));
	}
}

规则("巴蒂斯特-副武器-双发扳机")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待(0.065, 无视条件);
		If(弹药(事件玩家, 1) > 0);
			创建弹道(巴蒂斯特生化榴弹枪, 事件玩家, 眼睛位置(事件玩家), 面朝方向(事件玩家), 至地图, 治疗, 所在队伍(事件玩家), 50, 1, 3, 有益爆炸, 爆炸声音, 0, 60, 6, 0, 0, 20);
			等待直到 (正在使用辅助武器(事件玩家) != 真, 0.500);
			等待(0.050, 无视条件);
			设置弹药(事件玩家, 1, 弹药(事件玩家, 1) - 1);
		End;
	}
}

规则("西格玛-Q-炮塔放置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		事件玩家.sigma_battery_pos = 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 30, 空, 事件玩家, 假) + 上*5.0;

		创建效果(所有玩家(所在队伍(事件玩家)), 球, 颜色(蓝色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 数组(最后创建的实体);
		创建效果(所有玩家(对方队伍(所在队伍(事件玩家))), 球, 颜色(红色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 添加至数组(事件玩家.sigma_battery_pic, 最后创建的实体);
		等待(8, 无视条件);
		事件玩家.sigma_battery_pos = 空;
		消除效果(事件玩家.sigma_battery_pic[0]);
		消除效果(事件玩家.sigma_battery_pic[1]);
		事件玩家.sigma_battery_pic = 空;
	}
}

规则("西格玛-Q-炮塔攻击")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		事件玩家.sigma_battery_pos != 空;
	}

	动作
	{
		While(事件玩家.sigma_battery_pos != 空);
			事件玩家.sigma_battery_target = 已排序的数组(范围内玩家(事件玩家.sigma_battery_pos, 25, 对方队伍(所在队伍(事件玩家)), 表面), 存活(当前数组元素) && !具有状态(事件玩家, 无敌) && !具有状态(
				事件玩家, 相移) ? 标准化生命值(当前数组元素) - (正在空中(当前数组元素) && !正在跳跃(当前数组元素) ? (标准化生命值(当前数组元素) >= 0.500 ? 1 : -1) : 0) : 9999)[0];
			If(事件玩家.sigma_battery_target != 空 && 存活(事件玩家.sigma_battery_target));
				If(正在空中(事件玩家.sigma_battery_target) && !正在跳跃(事件玩家.sigma_battery_target));
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						55, 0.218, 3, 有害爆炸, 爆炸声音, 0, 96, 0.2292, 1.100, 0, 0);
					等待(0.335, 无视条件);
				Else;
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						55, 0.218, 3, 有害爆炸, 爆炸声音, 0, 48, 0.4583, 1.100, 0, 0);
					等待(0.670, 无视条件);
				End;
			Else;
				等待(0.050, 无视条件);
			End;
		End;
		事件玩家.sigma_battery_target = 空;
	}
}

规则("安娜-被动-治疗护盾")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(安娜);
		事件技能 != 空;
	}

	动作
	{
		If(事件技能 == 按钮(技能2));
			为玩家添加生命池(受治疗者, 生命值, 100, 假, 假);
			受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5.00, 空);
		Else;
			为玩家添加生命池(数组(受治疗者, 治疗者), 生命值, 20, 假, 假);
			受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.00, 空);
		End;
	}
}

规则("安娜-E-禁疗状态")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(安娜);
		事件技能 == 按钮(技能2);
	}

	动作
	{
		开始伤害调整(被攻击方, 所有玩家(所在队伍(攻击方)), 120, 受伤害者，伤害者及伤害百分比);
		被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 3, 空, 自定义字符串("Ana Biotic Grenade Vulnerable"));
	}
}

规则("安娜-被动-机械安娜")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(安娜);
		数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Ana HP"))) <= 0;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Ana HP") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		为玩家添加生命池(事件玩家, 护甲, 50, 真, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(安娜), 自定义字符串("Ana HP"));
	}
}

规则("安娜-终极技能-群体激素")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(安娜);
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家, 击晕, 0.1);
		所有玩家(所在队伍(事件玩家)).ana_q_flag = 事件玩家;

		治疗(所有玩家(所在队伍(事件玩家)), 事件玩家, 50);
		开始助攻(事件玩家, 所有玩家(所在队伍(事件玩家)), 助攻者和目标);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_assists, 上一个助攻ID, 总计消耗时间, 8, 英雄(安娜), 空);

		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 所有玩家(所在队伍(事件玩家)), 100 + 全局.args_ana[0], 受伤害者和伤害者);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 8, 英雄(安娜), 空);

		开始伤害调整(所有玩家(所在队伍(事件玩家)), 所有玩家(对方队伍(所在队伍(事件玩家))), 100 - 全局.args_ana[1], 受伤害者和伤害者);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 8, 英雄(安娜), 空);
	}
}

规则("安娜-终极技能-群体激素")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ana_q_flag != 空;
	}

	动作
	{
		事件玩家.i_sys_speed += 全局.args_ana[2];
		事件玩家.ana_q_flag.sys_default_status_pool[数量(事件玩家.ana_q_flag.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 全局.args_ana[2]), 总计消耗时间, 8, 英雄(安娜), 空);

		创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(蓝色), 事件玩家, 0, 可见，位置和半径);
		事件玩家.ana_q_flag.sys_default_status_pool[数量(事件玩家.ana_q_flag.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 8, 英雄(安娜), 空);

		事件玩家.ana_q_flag = 空;
	}
}

规则("卡西迪-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		卡西迪;
	}

	条件
	{
		事件技能 == 按钮(技能2);
	}

	动作
	{
		为玩家添加生命池(攻击方, 生命值, 30, 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(卡西迪));
		等待(3.0, 无视条件);
	}
}

规则("卡西迪-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		卡西迪;
	}

	条件
	{
		(事件技能 == 按钮(辅助攻击模式) || 事件技能 == 按钮(终极技能) || 事件技能 == 按钮(近身攻击)) == 真;
	}

	动作
	{
		为玩家添加生命池(攻击方, 生命值, 事件伤害 * 0.1, 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(卡西迪));
	}
}

规则("卡西迪-伤害衰减弥补")
{
	事件
	{
		玩家造成伤害;
		双方;
		卡西迪;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		攻击方.cassidy_distance = 相距距离(攻击方, 被攻击方);
		If(攻击方.cassidy_distance >= 30);
			攻击方.cassidy_distance = 事件伤害 * (7.0/3.0);
			伤害(被攻击方, 攻击方, 攻击方.cassidy_distance);
		Else If(攻击方.cassidy_distance > 20);
			攻击方.cassidy_distance = 事件伤害 * (100/(240-7*攻击方.cassidy_distance)-1);
			伤害(被攻击方, 攻击方, 攻击方.cassidy_distance);
		Else;
			攻击方.cassidy_distance = 0.0;
		End;

		为玩家添加生命池(攻击方, 生命值, (事件伤害 + 攻击方.cassidy_distance) * 0.1, 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(卡西迪));
	}
}

规则("卡西迪-六连换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(卡西迪);
		正在使用辅助武器(事件玩家) == 真;
		弹药(事件玩家, 0) <= 0;
	}

	动作
	{
		等待直到(正在装填(事件玩家) && !正在使用辅助武器(事件玩家), 1.0);
		等待(0.5, 无视条件);
		设置弹药(事件玩家, 0, 最大弹药(事件玩家, 0));
	}
}

规则("末日铁拳-减速")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(末日铁拳);
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(终极技能)) == 真;
	}

	动作
	{
		事件玩家.i_sys_speed -= 20;
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, -20), 总计消耗时间, 1.5, 空, 自定义字符串(
			"Doomfist Speed Down"));
	}
}

规则("末日铁拳-被动-无损蓄力-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 300, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串(
			"Doomfist Rocket Punch"));
		等待直到 (按钮被按下(事件玩家, 按钮(辅助攻击模式)) != 真 || 正在使用辅助武器(事件玩家) != 真, 5);
		// If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
		// 	等待(1, 无视条件);
		// End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Rocket Punch") ? 数组分割(当前数组元素, 0,
			2) : 当前数组元素);
	}
}

规则("末日铁拳-被动-无损蓄力-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 300, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串(
			"Doomfist Power Block"));
		等待直到 (正在使用技能 2(事件玩家) != 真, 5);
		// If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
		// 	等待(1, 无视条件);
		// End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Power Block") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
	}
}

规则("末日铁拳-被动-无损蓄力-S")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 300, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串(
			"Doomfist Seismic Slam"));
		等待直到 (正在使用技能 1(事件玩家) != 真, 5);
		// If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
		// 	等待(1, 无视条件);
		// End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Seismic Slam") ? 数组分割(当前数组元素, 0,
			2) : 当前数组元素);
	}
}

规则("艾什-主武器-霰弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		If(!正在使用辅助武器(事件玩家));
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
		Else;
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
		End;
	}
}

规则("布丽吉塔-被动-宁")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Tranquility"))) > 0;
		(!数组包含(全局.ca_zenyata_armor_heros, 所用英雄(事件玩家)) || 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 所用英雄(当前数组元素) == 英雄(布丽吉塔))) <= 0) == 真;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Tranquility") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
	}
}

规则("布丽吉塔-被动-宁")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Tranquility"))) == 0;
		数组包含(全局.ca_zenyata_armor_heros, 所用英雄(事件玩家)) == 真;
		数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 所用英雄(当前数组元素) == 英雄(布丽吉塔))) > 0;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 护甲, 25, 真, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 空, 自定义字符串(
			"Brigitte Tranquility"));
	}
}

规则("禅雅塔-被动-破")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	条件
	{
		弹药(事件玩家, 0) % 全局.args_zenyata[0] == 0;
		弹药(事件玩家, 0) != 最大弹药(事件玩家, 0);
	}

	动作
	{
		等待直到 (!正在使用辅助武器(事件玩家), 99999);
		If(!存活(事件玩家.zenyata_target) || !在视野内(事件玩家, 事件玩家.zenyata_target, 90));
			事件玩家.zenyata_target = 距离准星最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)));
		End;
		If(!存活(事件玩家.zenyata_target) || !在视野内(事件玩家, 事件玩家.zenyata_target, 90) || !在视线内(事件玩家, 事件玩家.zenyata_target, 敌方屏障阻挡视线));
			事件玩家.zenyata_target = 空;
		End;
		等待(0.100, 无视条件);
		创建追踪弹道(“秩序之光”光子发射器, 事件玩家, 空, 空, 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 50, 2, 0, 有益爆炸, 爆炸声音, 0.005, 90, 5, 0, 事件玩家.zenyata_target, 1);
	}
}

规则("禅雅塔-被动-破-索敌")
{
	事件
	{
		玩家造成伤害;
		双方;
		禅雅塔;
	}

	条件
	{
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		攻击方.zenyata_target = 被攻击方;
	}
}

规则("禅雅塔-终极技能-标记")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(禅雅塔);
		正在使用终极技能(事件玩家) == 真;
		全局.args_zenyata[1] > 0;
	}

	动作
	{
		While(所用英雄(事件玩家) == 英雄(禅雅塔) && 正在使用终极技能(事件玩家));
			范围内玩家(眼睛位置(事件玩家), 10.5, 所在队伍(事件玩家), 表面及敌方屏障).zenyata_flag = 事件玩家;
			等待(1.0, 无视条件);
		End;
	}
}

规则("禅雅塔-终极技能-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.zenyata_flag != 空;
		全局.args_zenyata[1] > 0;
	}

	动作
	{
		事件玩家.zenyata_flag = 空;

		If(数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Zenyata Transcendence"))) == 1);
			移除玩家的生命池(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Zenyata Transcendence"))[0][1]);
			为玩家添加生命池(事件玩家, 生命值, 全局.args_zenyata[1], 假, 假);
			事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Zenyata Transcendence") ? 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 6, 空, 自定义字符串("Zenyata Transcendence")) : 当前数组元素);
		Else If(数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Zenyata Transcendence"))) == 0);
			为玩家添加生命池(事件玩家, 生命值, 全局.args_zenyata[1], 假, 假);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 6, 空, 自定义字符串("Zenyata Transcendence"));
		End;
	}
}

规则("索杰恩-主武器-弹速增强")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真);
			设置弹道速度(事件玩家, 100000);
			等待直到 (正在使用主要武器(事件玩家) != 真, 1.500);
			中断;
		End;
		设置弹道速度(事件玩家, 100);
	}
}

规则("索杰恩-Q-伤害累积")
{
	事件
	{
		玩家造成伤害;
		双方;
		索杰恩;
	}

	条件
	{
		((事件技能 == 按钮(终极技能) && 正在使用终极技能(攻击方)) || (事件玩家.sojourn_Q_demage_count > 0 && 事件技能 == 按钮(辅助攻击模式))) == 真;
	}

	动作
	{
		伤害(被攻击方, 攻击方, 事件暴击 ? 攻击方.sojourn_Q_demage_count * 2 : 攻击方.sojourn_Q_demage_count);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(红色), 被攻击方, 1);
		If(正在使用终极技能(攻击方));
			攻击方.sojourn_Q_demage_count += 攻击方.sojourn_Q_demage_count > 120 ? 10 : 20;
		Else;
			攻击方.sojourn_Q_demage_count = 0;
		End;
	}
}

规则("索杰恩-Q-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sojourn_Q_demage_count = 0;
	}
}

规则("索杰恩-增伤")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 护甲, 100, 真, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 12, 英雄(索杰恩), 自定义字符串(
			"Sojourn Q hp pool"));
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 50, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 7, 英雄(索杰恩), 自定义字符串(
			"Sojourn Q adjust"));
		等待直到 (正在使用终极技能(事件玩家) != 真, 10);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Sojourn Q adjust") ? 数组分割(当前数组元素,
			0, 2) : 当前数组元素);
		等待(5, 无视条件);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Sojourn Q hp pool") ? 数组分割(当前数组元素,
			0, 2) : 当前数组元素);
	}
}

规则("索杰恩-主武器-弹药")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		最大弹药(事件玩家, 0) < 450;
	}

	动作
	{
		设置最大弹药(事件玩家, 0, 450);
		设置弹药(事件玩家, 0, 450);
	}
}

规则("索杰恩-主武器-命中")
{
	事件
	{
		玩家造成伤害;
		双方;
		索杰恩;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		事件玩家.sojourn_bullet_count += 1;
	}
}

规则("索杰恩-主武器-弹药")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		弹药(事件玩家, 0) == 450;
	}

	动作
	{
		事件玩家.sojourn_bullet_count = 0;
	}
}

规则("索杰恩-主武器-换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		事件玩家.sojourn_bullet_count >= 45;
		弹药(事件玩家, 0) != 450;
	}

	动作
	{
		While(弹药(事件玩家, 0) != 450 || 事件玩家.sojourn_bullet_count >= 45);
			设置弹药(事件玩家, 0, 0);
			等待(1.250, 当为“假”时中止);
		End;
	}
}

规则("索杰恩-文本显示")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("弹药：{0}", 45 - 事件玩家.sojourn_bullet_count), 自定义字符串("附加伤害：{0}", 事件玩家.sojourn_Q_demage_count), 自定义字符串(""), 顶部, 0,
			颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("温斯顿-基础生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Winston HP") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		等待直到(数量(已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Winston HP"))) <= 0, 99999);

		为玩家添加生命池(事件玩家, 护甲, 175, 真, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(温斯顿), 自定义字符串(
			"Winston HP"));

		为玩家添加生命池(事件玩家, 护盾, 100, 真, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(温斯顿), 自定义字符串(
			"Winston HP"));
	}
}

规则("温斯顿-副武器-蓄力")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		While((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) == 真);
			等待直到 ((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) != 真, 0.300);
			事件玩家.winston_power += 2;
		End;
		等待(0.500, 无视条件);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-副武器-击退")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		英雄(温斯顿) == 所用英雄(攻击方);
		事件技能 == 按钮(辅助攻击模式);
		攻击方.winston_power > 0;
	}

	动作
	{
		施加推力(被攻击方, 矢量(X方向分量(方向(攻击方, 被攻击方)), 0.250, Z方向分量(方向(攻击方, 被攻击方))),
			攻击方.winston_power < 10 ? 攻击方.winston_power * 2 : 攻击方.winston_power + 10, 至地图, 合并相反运动);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-被动-伤害调整")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Winston Back") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		开始伤害调整(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
	}
}

规则("查莉娅-被动-重力堡垒-HP记录")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	动作
	{
		While(真);
			事件玩家.zarya_hp_record_tmp = 添加至数组(事件玩家.zarya_hp_record, 生命值(事件玩家));
			If(数量(事件玩家.zarya_hp_record_tmp) > 10);
				事件玩家.zarya_hp_record = 数组分割(事件玩家.zarya_hp_record_tmp, 数量(事件玩家.zarya_hp_record_tmp) - 10, 10);
			Else;
				事件玩家.zarya_hp_record = 事件玩家.zarya_hp_record_tmp;
			End;
			等待(0.100, 无视条件);
		End;
	}
}

规则("查莉娅-文本栏")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("免伤：{0} - 治疗增幅：{1}", 100 - 较小(较大(首个(事件玩家.zarya_hp_record) - 最后(事件玩家.zarya_hp_record), 0) / 5, 40), (正在使用技能 1(事件玩家) ? 120 : 120 - 较小(较大(最后(事件玩家.zarya_hp_record) - 首个(事件玩家.zarya_hp_record), 0) / 10, 20))), 自定义字符串(""), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("查莉娅-被动-重力堡垒-调整")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		(事件玩家.zarya_weaken == 空 || 事件玩家.zarya_heal_inc == 空) == 真;
	}

	动作
	{
		If(事件玩家.zarya_weaken == 空);
			开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 100 - 较小(较大(首个(事件玩家.zarya_hp_record) - 最后(事件玩家.zarya_hp_record), 0) / 5, 40), 受伤害者，伤害者及伤害百分比);
			事件玩家.zarya_weaken = 上一个伤害调整ID;
		End;
		If(事件玩家.zarya_heal_inc == 空);
			开始治疗调整(事件玩家, 所有玩家(所在队伍(事件玩家)), (正在使用技能 1(事件玩家) ? 120 : 120 - 较小(较大(最后(事件玩家.zarya_hp_record) - 首个(事件玩家.zarya_hp_record), 0) / 10, 20)), 受治疗者，治疗者及治疗百分比);
			事件玩家.zarya_heal_inc = 上一个治疗调整ID;
		End;
	}
}

规则("查莉娅-被动-重力堡垒-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		英雄(查莉娅) != 所用英雄(事件玩家);
		(事件玩家.zarya_weaken != 空 || 事件玩家.zarya_heal_inc != 空) == 真;
	}

	动作
	{
		If(事件玩家.zarya_weaken != 空);
			停止伤害调整(事件玩家.zarya_weaken);
			事件玩家.zarya_weaken = 空;
		End;
		If(事件玩家.zarya_heal_inc != 空);
			停止治疗调整(事件玩家.zarya_heal_inc);
			事件玩家.zarya_heal_inc = 空;
		End;
	}
}

规则("查莉娅-超级护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(查莉娅);
		(正在使用技能 1(事件玩家) || 正在使用技能 2(事件玩家)) == 真;
	}

	动作
	{
		While((正在使用技能 1(事件玩家) || 正在使用技能 2(事件玩家)) == 真);
			为玩家添加生命池(事件玩家, 生命值, 15, 假, 假);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(查莉娅));
			等待(0.2, 无视条件);
		End;
	}
}

规则("查莉娅-弹药恢复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(查莉娅);
		(正在使用主要武器(事件玩家) || 正在使用辅助武器(事件玩家) || 正在装填(事件玩家)) != 真;
		弹药(事件玩家, 0) < 最大弹药(事件玩家, 0);
		弹药(事件玩家, 0) > 0;
	}

	动作
	{
		While(弹药(事件玩家, 0) < 最大弹药(事件玩家, 0) && 弹药(事件玩家, 0) > 0 && !(正在使用主要武器(事件玩家) || 正在使用辅助武器(事件玩家) || 正在装填(事件玩家)) && 所用英雄(事件玩家) == 英雄(查莉娅));
			设置弹药(事件玩家, 0, 较小(最大弹药(事件玩家, 0), 弹药(事件玩家, 0) + 1));
			等待(0.1, 无视条件);
		End;
	}
}

规则("查莉娅-弹药恢复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(查莉娅);
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		If(弹药(事件玩家, 0) == 0 || 正在装填(事件玩家));
			设置弹药(事件玩家, 0, 最大弹药(事件玩家, 0) + 25);
		Else;
			设置弹药(事件玩家, 0, 弹药(事件玩家, 0) + 25);
		End;
	}
}

规则("查莉娅-弹药恢复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(查莉娅);
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		If(弹药(事件玩家, 0) == 0 || 正在装填(事件玩家));
			设置弹药(事件玩家, 0, 最大弹药(事件玩家, 0) + 25);
		Else;
			设置弹药(事件玩家, 0, 弹药(事件玩家, 0) + 25);
		End;
	}
}

禁用 规则("秩序之光-Q-大招增幅")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		秩序之光;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		创建效果(事件玩家, 火花, 颜色(天蓝色), 事件玩家, 15, 可见，位置和半径);
		事件玩家.symmetra_Q_effect = 最后创建的实体;
		While((正在使用终极技能(事件玩家) && 存活(事件玩家)) == 真);
			事件玩家.symmetra_Q_players = 从数组中移除(范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
			For 玩家变量(事件玩家, symmetra_Q_inedx, 0, 数量(事件玩家.symmetra_Q_players), 1);
				设置终极技能充能(事件玩家.symmetra_Q_players[事件玩家.symmetra_Q_inedx], 终极技能充能百分比(事件玩家.symmetra_Q_players[事件玩家.symmetra_Q_inedx]) + 1);
				等待直到 ((正在使用终极技能(事件玩家) && 存活(事件玩家)) != 真, 0);
			End;
			事件玩家.symmetra_Q_inedx = 0;
			等待直到 ((正在使用终极技能(事件玩家) && 存活(事件玩家)) != 真, 0.430);
		End;
		消除效果(事件玩家.symmetra_Q_effect);
		事件玩家.symmetra_Q_effect = 空;
	}
}

规则("秩序之光-Q-大招增幅")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(秩序之光);
		存活(事件玩家) == 真;
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		创建效果(事件玩家, 火花, 颜色(天蓝色), 事件玩家, 15, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 8, 英雄(秩序之光), 自定义字符串("Symmetra Q Effect"));
		While((正在使用终极技能(事件玩家) && 存活(事件玩家)) == 真);
			// 从数组中移除(范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家).symmetra_Q_inedx += 1;
			已过滤的数组(范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障), 当前数组元素 != 事件玩家 && 存活(当前数组元素)).symmetra_Q_inedx += 1;
			等待直到 ((正在使用终极技能(事件玩家) && 存活(事件玩家)) != 真, 0.40);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Symmetra Q Effect") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("秩序之光-Q-大招增幅-标记")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) != 真;
		事件玩家.symmetra_Q_inedx > 0;
	}

	动作
	{
		事件玩家.symmetra_Q_inedx = 0;
	}
}

规则("秩序之光-Q-大招增幅-标记")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.symmetra_Q_inedx + 事件玩家.symmetra_Q_players > 0;
		终极技能充能百分比(事件玩家) < 100;
	}

	动作
	{
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 事件玩家.symmetra_Q_inedx + 事件玩家.symmetra_Q_players);
		事件玩家.symmetra_Q_inedx = 0;
		事件玩家.symmetra_Q_players = 0;
	}
}

规则("秩序之光-Q-大招增幅-标记存储")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.symmetra_Q_inedx > 0;
		终极技能充能百分比(事件玩家) == 100;
	}

	动作
	{
		事件玩家.symmetra_Q_players += 事件玩家.symmetra_Q_inedx;
		事件玩家.symmetra_Q_inedx = 0;
	}
}

规则("秩序之光-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		秩序之光;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		攻击方.symmetra_demage += 事件伤害;
	}
}

规则("秩序之光-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(秩序之光);
		事件玩家.symmetra_demage > 0;
	}

	动作
	{
		While(所用英雄(事件玩家) == 英雄(秩序之光));
			等待直到(事件玩家.symmetra_demage > 0, 9999);
			等待(1, 无视条件);
			If(事件玩家.symmetra_demage > 0);
				为玩家添加生命池(范围内玩家(眼睛位置(事件玩家), 8, 所在队伍(事件玩家), 表面及敌方屏障), 生命值, 事件玩家.symmetra_demage * 0.3, 假, 假);
				事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(秩序之光));
			End;
			事件玩家.symmetra_demage = 0;
		End;
	}
}

规则("渣客女王-基础生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Junker Queen Back") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);

		If(全局.args_junkerqueen[5] > 0);
			为玩家添加生命池(事件玩家, 护甲, 全局.args_junkerqueen[5], 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(渣客女王), 自定义字符串(
				"Junker Queen Back"));
		End;
	}
}


规则("渣客女王-被动-标记")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(渣客女王);
		(事件技能 == 按钮(技能2) || 事件技能 == 按钮(辅助攻击模式) || 事件技能 == 按钮(近身攻击) || 事件技能 == 按钮(终极技能)) == 真;
	}

	动作
	{
		被攻击方.junkerqueen_timer = 0.400;
		If(被攻击方.junkerqueen_effect != 空 && 攻击方 != 被攻击方.junkerqueen_effect[0]);
			停止伤害调整(事件玩家.junkerqueen_effect[1]);
			停止治疗调整(事件玩家.junkerqueen_effect[2]);
			事件玩家.junkerqueen_effect = 空;
		End;
		If(被攻击方.junkerqueen_effect == 空);
			被攻击方.junkerqueen_effect = 数组(攻击方);
			开始伤害调整(所有玩家(所在队伍(攻击方)), 被攻击方, 100 - 全局.args_junkerqueen[0], 受伤害者和伤害者);
			被攻击方.junkerqueen_effect = 添加至数组(被攻击方.junkerqueen_effect, 上一个伤害调整ID);
			开始治疗调整(被攻击方, 所有玩家(所有队伍), 100 - 全局.args_junkerqueen[1], 受治疗者和治疗者);
			被攻击方.junkerqueen_effect = 添加至数组(被攻击方.junkerqueen_effect, 上一个治疗调整ID);
		End;
	}
}

规则("渣客女王-被动-标记-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.junkerqueen_timer <= 0;
		事件玩家.junkerqueen_effect != 空;
	}

	动作
	{
		停止伤害调整(事件玩家.junkerqueen_effect[1]);
		停止治疗调整(事件玩家.junkerqueen_effect[2]);
		事件玩家.junkerqueen_effect = 空;
	}
}

规则("渣客女王-shift")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(渣客女王);
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		事件玩家.junkerqueen_players = 数组(范围内玩家(眼睛位置(事件玩家), 15, 所在队伍(事件玩家), 表面及敌方屏障), 总计消耗时间);
		事件玩家.junkerqueen_players[0].junkerqueen_flag = 真;

		While(正在使用技能 1(事件玩家) == 真 && 所用英雄(事件玩家) == 英雄(渣客女王) && (总计消耗时间 - 事件玩家.junkerqueen_players[1]) <= 3.0);
			为玩家添加生命池(事件玩家.junkerqueen_players[0], 生命值, 5, 假, 假);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3.0, 英雄(渣客女王), 自定义字符串(
				"Junker Queen Back"));
			等待(0.20, 无视条件);
		End;
	}
}

规则("渣客女王-E-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		全局.args_junkerqueen[3] > 0;
	}

	动作
	{
		事件玩家.d_sys_status_thorns += 全局.args_junkerqueen[3];
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_status_thorns, 数组(事件玩家, 0.25), 总计消耗时间, 3.0, 英雄(渣客女王), 自定义字符串("Junker Queen Carnage Thorns"));
		等待直到(!正在使用技能 2(事件玩家), 3.0);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Junker Queen Carnage Thorns") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("渣客女王-终极技能-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		全局.args_junkerqueen[4] > 0;
	}

	动作
	{
		事件玩家.d_sys_status_thorns += 全局.args_junkerqueen[4];
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_status_thorns, 数组(事件玩家, 0.25), 总计消耗时间, 6.0, 英雄(渣客女王), 自定义字符串("Junker Queen Rampage Thorns"));
		等待直到(!正在使用终极技能(事件玩家), 6.0);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Junker Queen Rampage Thorns") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("渣客女王-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.junkerqueen_flag != 空;
		全局.args_junkerqueen[2] > 0;
	}

	动作
	{
		事件玩家.junkerqueen_flag = 空;

		事件玩家.d_sys_status_thorns += 全局.args_junkerqueen[2];
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_status_thorns, 数组(事件玩家, 0.25), 总计消耗时间, (所用英雄(事件玩家) == 英雄(渣客女王)) ? 5 : 3, 空, 空);
	}
}

规则("黑百合-副武器-开镜-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		黑百合;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.widowmaker_hp_pool == 空;
		事件玩家.widowmaker_hp_pool_timer <= 0;
	}

	动作
	{
		等待(0.200, 当为“假”时中止);
		为玩家添加生命池(事件玩家, 生命值, 300, 假, 假);
		事件玩家.widowmaker_hp_pool = 最后创建的生命池;
	}
}

规则("黑百合-副武器-开镜-护盾破碎")
{
	事件
	{
		玩家受到伤害;
		双方;
		黑百合;
	}

	条件
	{
		事件玩家.widowmaker_hp_pool != 空;
	}

	动作
	{
		等待(0.300, 当为“假”时中止);
		播放效果(攻击方, 爆炸声音, 颜色(白色), 攻击方, 9999);
		播放效果(被攻击方, 爆炸声音, 颜色(白色), 被攻击方, 9999);
		事件玩家.widowmaker_hp_pool_timer = 正在使用终极技能(事件玩家) ? 2 : 6;
	}
}

规则("黑百合-副武器-开镜-护盾清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.widowmaker_hp_pool != 空;
		(所用英雄(事件玩家) != 英雄(黑百合) || 正在使用辅助武器(事件玩家) != 真 || 事件玩家.widowmaker_hp_pool_timer > 0) == 真;
	}

	动作
	{
		移除玩家的生命池(事件玩家.widowmaker_hp_pool);
		事件玩家.widowmaker_hp_pool = 空;
	}
}

规则("黑百合-Q-弹匣拓展")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		黑百合;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置最大弹药(事件玩家, 0, 70);
		设置弹药(事件玩家, 0, 弹药(事件玩家, 0) + 35);
		等待直到 (正在使用终极技能(事件玩家) != 真, 20);
		设置最大弹药(事件玩家, 0, 35);
	}
}

规则("黑百合-Q-伤害增幅")
{
	事件
	{
		玩家造成伤害;
		双方;
		黑百合;
	}

	条件
	{
		正在使用终极技能(攻击方) == 真;
		正在使用辅助武器(攻击方) == 真;
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		伤害(被攻击方, 攻击方, 事件伤害);
	}
}

规则("堡垒-坦克炮弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		堡垒;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		While(正在使用技能 1(事件玩家) && 正在使用主要武器(事件玩家));
			If(随机实数(0, 1) < 水平速度(事件玩家) * 0.160);
				创建弹道(“法老之鹰”火箭, 事件玩家, 眼睛位置(事件玩家), 面朝方向(事件玩家), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 30 + 最大生命值(事件玩家) * 0.100, 0.500, 3, 有害爆炸, 爆炸声音, 0, 60, 3,
					0, 0, 0);
			End;
			等待(0.500, 无视条件);
		End;
	}
}

规则("路霸-文字")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		路霸;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("单打独斗 强化：{0}% 强化近身攻击：{1}%", 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, (数量(
			已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) + 1) * 5), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("路霸-被动-单打独斗")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		路霸;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Roadhog Alone") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家, 100 + 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串(
			"Roadhog Alone"));
		开始伤害调整(事件玩家, 所有玩家(所有队伍), 100 - 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串(
			"Roadhog Alone"));
		开始治疗调整(事件玩家, 所有玩家(所有队伍), 100 + 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, 受治疗者，治疗者及治疗百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_heal_adjust, 上一个治疗调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串(
			"Roadhog Alone"));
	}
}

规则("路霸-被动-单打独斗-移除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.roadhog_mates_flag == 真;
	}

	动作
	{
		等待(5, 当为“假”时中止);
		事件玩家.roadhog_mates_flag = 假;
	}
}

规则("路霸-被动-单打独斗-队友阵亡")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	动作
	{
		事件玩家.roadhog_mates_flag = 真;
	}
}

规则("路霸-被动-单打独斗-钩子标记")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件技能 == 按钮(技能1);
		所用英雄(攻击方) == 英雄(路霸);
		正在使用技能 1(攻击方) == 真;
	}

	动作
	{
		攻击方.roadhog_hit_flag = 数组(1, 被攻击方);
	}
}

规则("路霸-被动-单打独斗-近身攻击")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		所用英雄(攻击方) == 英雄(路霸);
		攻击方.roadhog_hit_flag[0] > 0;
		攻击方.roadhog_hit_flag[1] == 被攻击方;
	}

	动作
	{
		攻击方.roadhog_hit_flag = 空;
		等待直到 (!正在使用主要武器(攻击方), 1);
		伤害(被攻击方, 攻击方, 最大生命值(被攻击方) * (数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) + 1) * 0.080);
	}
}

规则("伊拉锐-护盾发生器")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(伊拉锐);
		事件技能 == 空;
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 正在使用终极技能(治疗者) ? 300 : 60, 假, 真);
		治疗者.sys_default_status_pool[数量(治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 4.5, 英雄(伊拉锐));
		受治疗者.illari_poison = 治疗者;
		等待(1.00, 无视条件);
	}
}

规则("伊拉锐-右键-护盾发生器")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(伊拉锐);
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 事件治疗 * 12.0, 假, 真);
		治疗者.sys_default_status_pool[数量(治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3.00, 英雄(伊拉锐));
	}
}

规则("伊拉锐-烈日强化")
{
	事件
	{
		玩家造成伤害;
		双方;
		全部;
	}

	条件
	{
		攻击方.illari_poison != 空;
		事件伤害 > 3;
		事件技能 != 空;
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(辅助攻击模式) || 事件技能 == 按钮(近身攻击) || (数量(已过滤的数组(全局.ch_normal_attack_dist, 当前数组元素[0] == 所用英雄(事件玩家) && 当前数组元素[1] == 事件技能)) > 0)) == 真;
	}

	动作
	{
		伤害(被攻击方, 攻击方.illari_poison, 事件伤害 * 0.4);
		攻击方.illari_poison = 空;
	}
}

规则("拉玛刹-增加吸血")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		拉玛刹;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		If(数量(事件玩家.ramattra_absorb) > 0);
			事件玩家.ramattra_absorb[0] = 全局.args_ramattra[0] * 0.01;
		Else;
			事件玩家.ramattra_absorb = 数组(全局.args_ramattra[0] * 0.01, 0.0, 空, 空, 0, 0.0, 0.0, 0.0);
		End;
	}
}

规则("拉玛刹-增加吸血")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		拉玛刹;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		If(数量(事件玩家.ramattra_absorb) > 0);
			事件玩家.ramattra_absorb[0] = 全局.args_ramattra[1] * 0.01;
		Else;
			事件玩家.ramattra_absorb = 数组(全局.args_ramattra[1] * 0.01, 0.0, 空, 空, 0, 0.0, 0.0, 0.0);
		End;
	}
}

规则("拉玛刹-去除吸血")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		((!正在使用技能 1(事件玩家) && !正在使用终极技能(事件玩家)) || (所用英雄(事件玩家) != 英雄(拉玛刹))) == 真;
		数量(事件玩家.ramattra_absorb) > 0;
	}

	动作
	{
		事件玩家.ramattra_absorb = 空;
	}
}

规则("拉玛刹-过度治疗")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(拉玛刹);
		数量(事件玩家.ramattra_absorb) > 0;
	}

	动作
	{
		While(数量(事件玩家.ramattra_absorb) > 0 && 所用英雄(事件玩家) == 英雄(拉玛刹));
			事件玩家.ramattra_absorb[4] = 总计消耗时间;
			If(事件玩家.ramattra_absorb[1] > 0);
				事件玩家.ramattra_absorb[5] = 生命值(事件玩家);
				开始持续治疗(事件玩家, 事件玩家, 全局.args_ramattra[2], 事件玩家.ramattra_absorb[1] / 全局.args_ramattra[2]);
				事件玩家.ramattra_absorb[2] = 上一个持续治疗效果ID;

				等待直到(标准化生命值(事件玩家) >= 1.0, 全局.args_ramattra[2]);
				停止持续治疗(事件玩家.ramattra_absorb[2]);

				事件玩家.ramattra_absorb[6] = 较小(事件玩家.ramattra_absorb[1], 事件玩家.ramattra_absorb[1]-(最大生命值(事件玩家)-事件玩家.ramattra_absorb[5]));
				If(总计消耗时间 - 事件玩家.ramattra_absorb[4] < 全局.args_ramattra[2] && 标准化生命值(事件玩家) >= 1.0 && 事件玩家.ramattra_absorb[6] > 0);
					移除玩家的生命池(事件玩家.ramattra_absorb[3]);
					为玩家添加生命池(事件玩家, 生命值, 事件玩家.ramattra_absorb[6], 假, 假);
					事件玩家.ramattra_absorb[3] = 最后创建的生命池;
					事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 10.0, 英雄(拉玛刹));
				End;
			End;

			事件玩家.ramattra_absorb[1] = 0.0;
			等待直到(总计消耗时间 - 事件玩家.ramattra_absorb[4] >= 1.0, 1.0);
		End;

		事件玩家.ramattra_absorb = 空;
	}
}

规则("拉玛刹-吸血")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(拉玛刹);
		数量(攻击方.ramattra_absorb) > 0;
		攻击方.ramattra_absorb[0] > 0;
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(终极技能) || 事件技能 == 按钮(近身攻击) || 事件技能 == 按钮(技能2)) == 真;
	}

	动作
	{
		攻击方.ramattra_absorb[1] += 事件伤害 * 攻击方.ramattra_absorb[0];
	}
}

规则("莱因哈特-被动-守护-伤害累计")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(被攻击方) == 英雄(莱因哈特);
	}

	动作
	{
		If(被攻击方.reinhardt_shield[1] + 事件伤害 > 生命值(被攻击方) * 0.300);
			被攻击方.reinhardt_shield = 数组(0, 0);
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 0.500, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.500, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 2, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 2.500, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(莱因哈特));
			等待(10, 当为“假”时中止);
		End;
		被攻击方.reinhardt_shield = 数组(3, 被攻击方.reinhardt_shield[1] + 事件伤害);
		Else;
	}
}

规则("莱因哈特-被动-守护-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		莱因哈特;
	}

	条件
	{
		事件玩家.reinhardt_shield != 空;
		事件玩家.reinhardt_shield[1] > 0;
		事件玩家.reinhardt_shield[0] <= 0;
	}

	动作
	{
		事件玩家.reinhardt_shield = 数组(0, 0);
	}
}

规则("莱因哈特-终极技能-迅猛烈焰")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		(所用英雄(攻击方) == 英雄(莱因哈特) || 正在复制的英雄(攻击方) == 英雄(莱因哈特)) == 真;
		事件技能 == 按钮(终极技能);
	}

	动作
	{
		等待直到 (具有状态(被攻击方, 击倒), 5);
		If(具有状态(被攻击方, 击倒));
			等待(随机实数(0.300, 0.800), 无视条件);
			创建弹道(莱因哈特烈焰打击, 攻击方, 所选位置(被攻击方) + 矢量(0, 10, 0), 下, 至地图, 伤害, 所在队伍(被攻击方), 120, 0.200, 3, 有害爆炸, 爆炸声音, 0, 25, 5, 0, 0, 0);
		End;
	}
}

规则("士兵76-E-护盾")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(士兵：76);
		事件技能 == 按钮(技能2);
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 5, 假, 假);
		治疗者.sys_default_status_pool[数量(治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3.00, 英雄(士兵：76));
	}
}

规则("雾子-自动治疗")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(雾子);
		存活(事件玩家) == 真;
	}

	动作
	{
		While(所用英雄(事件玩家) == 英雄(雾子) && 存活(事件玩家));
			事件玩家.kiriko_heal_target = 已排序的数组(已过滤的数组(范围内玩家(眼睛位置(事件玩家), 34, 所在队伍(事件玩家), 表面), 存活(当前数组元素) && (最大生命值(当前数组元素) > 生命值(当前数组元素)) && (当前数组元素 != 事件玩家)), 标准化生命值(当前数组元素));
			If(数量(事件玩家.kiriko_heal_target) > 0 && 事件玩家.kiriko_heal_target[0] != 空 && 存活(事件玩家.kiriko_heal_target[0]));
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 13, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 13, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 13, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 13, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 13, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 方向(事件玩家, 事件玩家.kiriko_heal_target[0]), 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家.kiriko_heal_target[0], 1);
				等待(0.5, 无视条件);
			Else If(标准化生命值(事件玩家) < 1.0);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 上, 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家, 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 上, 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家, 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 上, 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家, 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 上, 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家, 1);
				等待(0.1, 无视条件);
				创建追踪弹道(“天使”天使冲击枪, 事件玩家, 空, 上, 至地图, 治疗, 所在队伍(事件玩家), 6, 1, 0, 有益爆炸, 爆炸声音, 0.01, 24, 3, 0, 事件玩家, 1);
				等待(0.5, 无视条件);
			Else;
				等待(1.5, 无视条件);
			End;

		End;
	}
}

规则("托比昂-熔火护甲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(托比昂);
		正在使用终极技能(事件玩家) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(主要攻击模式));
		禁用按钮(事件玩家, 按钮(辅助攻击模式));
		等待(0.5, 无视条件);

		If(存活(事件玩家) && 所用英雄(事件玩家) == 英雄(托比昂));
			事件玩家.torbjorn_Q_begin = 数组(范围内玩家(事件玩家, 30, 所在队伍(事件玩家), 关闭), 总计消耗时间);
			事件玩家.torbjorn_Q_begin[0].torbjorn_Q_flag = 事件玩家;

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 0.5, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 1.0, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 1.5, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 2.0, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 2.5, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 3.0, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 3.5, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 4.0, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 4.5, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 5.0, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 5.5, 英雄(托比昂));

			为玩家添加生命池(事件玩家.torbjorn_Q_begin[0], 护甲, 40, 真, 真);
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 事件玩家.torbjorn_Q_begin[1], 6.0, 英雄(托比昂));
		End;

		等待直到(所用英雄(事件玩家) != 英雄(托比昂) || !正在使用终极技能(事件玩家), 3.0);

		可用按钮(事件玩家, 按钮(主要攻击模式));
		可用按钮(事件玩家, 按钮(辅助攻击模式));
	}
}

规则("托比昂-熔火护甲-效果")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.torbjorn_Q_flag != 空;
	}

	动作
	{
		事件玩家.torbjorn_Q_flag = 空;

		创建效果(所有玩家(所有队伍), 托比昂热力过载效果, 颜色(橙色), 所选位置(事件玩家), 10, 可见，位置，半径和颜色);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 6.0, 空);

		创建效果(所有玩家(所有队伍), 艾什延时雷管燃烧粒子效果, 颜色(红色), 所选位置(事件玩家), 10, 可见，位置，半径和颜色);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 6.0, 空);

		创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(橙色), 所选位置(事件玩家), 10, 可见，位置，半径和颜色);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 6.0, 空);
	}
}

规则("半藏-蓄力")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(半藏);
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		事件玩家.hanzo_focus = 数组(总计消耗时间, -1);
		等待直到(所用英雄(事件玩家) != 英雄(半藏) || !按钮被按下(事件玩家, 按钮(主要攻击模式)) || 按钮被按下(事件玩家, 按钮(辅助攻击模式)), 99999);
		If(总计消耗时间 - 事件玩家.hanzo_focus[0] > 0.35 && !按钮被按下(事件玩家, 按钮(辅助攻击模式)));
			创建弹道(“路霸”爆裂枪废铁球, 事件玩家, 空, 空, 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 30, 0.5, 3, 有害爆炸, 爆炸声音, 0, 较小(110, (总计消耗时间 - 事件玩家.hanzo_focus[0]) * 115), 3, 0, 0, 9.8);
		End;
	}
}

禁用 规则("debug-hp")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		创建地图文本(所有玩家(所有队伍), 自定义字符串("{0} / {1}", 生命值(事件玩家), 最大生命值(事件玩家)), 事件玩家, 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色), 默认可见度);
	}
}

规则("")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			事件玩家.debug_1 = 自定义字符串("{0} {1}", 事件玩家.illari_poison[0][1], 事件玩家.illari_poison[0][2]);
			等待(0.100, 无视条件);
		End;
	}
}

规则("debug")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		事件玩家.d_sys_cd = 0.500;
		设置终极技能充能(事件玩家, 100);
		If(事件玩家.debug_robot == 空);
			创建HUD文本(事件玩家, 自定义字符串("{0} - {1}", 事件玩家.debug_2, 技能资源(事件玩家, 按钮(辅助攻击模式))), 自定义字符串("shift：{0} E：{1} Q：{2}", 正在使用技能 1(事件玩家), 正在使用技能 2(
				事件玩家), 正在使用终极技能(事件玩家)), 自定义字符串("主武器：{0} 副武器：{1} {2}", 正在使用主要武器(事件玩家), 正在使用辅助武器(事件玩家), 自定义字符串("{0} - {1} - {2}", 事件玩家.ramattra_absorb,
				最大生命值(事件玩家), 生命值(事件玩家))), 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			生成机器人(英雄(西格玛), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			// 生成机器人(英雄(托比昂), 队伍1, -1, 事件玩家, 矢量(0, 0, 0));
			// 设置状态(事件玩家.debug_robot2, 事件玩家.debug_robot2, 无法杀死, 99999);
			生成机器人(英雄(艾什), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(卢西奥), 队伍1, -1, 事件玩家, 矢量(0, 0, 0));
			事件玩家.debug_robot2 = 最后创建的实体;
			生成机器人(英雄(禅雅塔), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			事件玩家.debug_robot = 最后创建的实体;
			// 设置最大生命值(事件玩家.debug_robot, 9999);
			开始持续伤害(所有玩家(所在队伍(事件玩家)), 事件玩家.debug_robot2, 99999, 10);
		Else;
			传送(所有玩家(所有队伍), 事件玩家);
		End;
		等待(0.5, 无视条件);
		设置终极技能充能(事件玩家.debug_robot, 100);
		设置终极技能充能(事件玩家.debug_robot2, 100);
		设置技能冷却(事件玩家.debug_robot2, 按钮(技能2), 0);
		等待(0.5, 无视条件);
		开始按下按钮(事件玩家.debug_robot2, 按钮(技能2));
		开始按下按钮(事件玩家.debug_robot, 按钮(终极技能));
		// 等待(1, 无视条件);
	}
}

规则("debug_hit")
{
	事件
	{
		玩家造成伤害;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		事件玩家.debug_2 = 字符串("{0} - {1}", 事件伤害, 事件技能);
	}
}

规则("debug_heal")
{
	事件
	{
		玩家造成治疗;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		事件玩家.debug_2 = 字符串("{0} - {1}", 事件治疗, 事件技能);
	}
}