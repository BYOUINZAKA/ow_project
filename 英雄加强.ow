设置
{
	模式
	{
		占领要点
		{
			获胜得分: 3
			计分速度: 30%

			禁用地图
			{
				春节漓江塔
			}
		}

		攻击护送
		{
			启用地图
			{
			}
		}

		机动推进
		{
			启用地图
			{
			}
		}

		运载目标
		{
			启用地图
			{
			}
		}

		闪点作战
		{
			获胜得分: 10
			计分速度: 30%

			启用地图
			{
			}
		}

		综合
		{
			职责限制: 1重装，2输出，2支援
		}
	}

	英雄
	{
		综合
		{
			死神
			{
				幽灵形态 冷却时间: 125%
			}

			猎空
			{
				无需装弹: 开启
			}

			艾什
			{
				延时雷管引爆时间: 5%
			}
		}
	}

	扩展
	{
		爆炸声音
		弹道
	}
}

变量
{
	全局:
		0: random

	玩家:
		0: mei_Q_timer
		1: mei_Q_pos
		2: mei_Q_dec
		3: tracer_energy
		4: tracer_energy_reset
		5: tracer_energy_text
		6: tracer_energy_last
		7: tracer_hit
		8: tracer_hit_last
		9: tracer_curr_hit
		10: genji_reduce
		11: genji_demage
		12: genji_pool
		13: genji_e_pool
		15: reaper_shadow
		20: buligita_players
		21: buligita_light
		22: buligita_dec_id
		23: buligita_heal_ring
		24: buligita_base_armor
		25: ana_healing
		26: ana_healing_preventing
		27: ana_healing_preventing_status
		30: lucio_debuff_clear
		31: lucio_slice_dec
		32: lucio_e_inc
		35: doomfist_pool
		40: sombra_demage
		41: sombra_timer
		42: sombra_player
		43: sombra_hacked
		45: dva_hp_pool
		46: dva_pools_list
		47: dva_pool_idx
		48: dva_clear_flag
		49: dva_timer
		50: wrecking_ball_dec
		51: wrecking_ball_players
		52: wrecking_ball_dec_id
		55: cassidy_hp_pool
		56: cassidy_pools_list
		57: cassidy_pool_idx
		58: cassidy_clear_flag
		59: cassidy_timer
		60: orisa_teammates
		61: orisa_reduce
		63: orisa_master
		65: sigma_battery_pos
		66: sigma_battery_pic
		67: sigma_battery_target
		70: baptiste_shift_hp
		75: zenyata_shift_armor
		76: zenyata_e_player
		77: zenyata_e_hurt
		78: zenyata_shift_flag
		80: winston_power
		81: winston_inc
		100: debug_robot
		101: debug_1
		102: debug_2
		103: debug_3
		104: debug_4
		105: debug_5
		106: debug_6
		107: debug_7
		108: debug_8
		109: debug_9
}

规则("随机数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		While(真);
			全局.random = 随机实数(0, 1);
			等待(0, 无视条件);
		End;
	}
}

规则("初始化debug变量")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		事件玩家.debug_1 = 空;
		事件玩家.debug_2 = 空;
		事件玩家.debug_3 = 空;
		事件玩家.debug_4 = 空;
		事件玩家.debug_5 = 空;
		事件玩家.debug_6 = 空;
		事件玩家.debug_7 = 空;
		事件玩家.debug_8 = 空;
		事件玩家.debug_9 = 空;
	}
}

规则("艾什-左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(主要攻击模式));
		等待直到 (正在使用辅助武器(事件玩家) != 真, 99999);
		可用按钮(事件玩家, 按钮(主要攻击模式));
	}
}

规则("艾什-右键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		If(弹药(事件玩家, 0) > 0 && 正在使用辅助武器(事件玩家) == 真);
			创建弹道(美冰锥, 事件玩家, 空, 空, 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 75, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 1, 0, 0, 0);
			播放效果(所有玩家(所有队伍), D.Va微型飞弹爆炸声音, 颜色(白色), 眼睛位置(事件玩家), 150);
			设置弹药(事件玩家, 0, 弹药(事件玩家, 0) - 1);
		End;
		等待(0.070, 无视条件);
		If(弹药(事件玩家, 0) > 0 && 正在使用辅助武器(事件玩家) == 真);
			创建弹道(美冰锥, 事件玩家, 空, 空, 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 75, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 1, 0, 0, 0);
			播放效果(所有玩家(所有队伍), D.Va微型飞弹爆炸声音, 颜色(白色), 眼睛位置(事件玩家), 150);
			设置弹药(事件玩家, 0, 弹药(事件玩家, 0) - 1);
		End;
		等待(0.600, 无视条件);
	}
}

规则("艾什-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 40, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
	}
}

规则("伊拉锐-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		伊拉锐;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		While(正在使用终极技能(事件玩家) == 真);
			If(空数组 != 范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障));
				创建追踪弹道(巴蒂斯特生化榴弹枪, 事件玩家, 所选位置(事件玩家), 空, 至地图, 治疗, 所在队伍(事件玩家), 50, 0.500, 3, 有益爆炸, 巴蒂斯特生化榴弹枪爆炸声音, 0, 10, 6, 0, 数组随机取值(范围内玩家(事件玩家, 15,
					所在队伍(事件玩家), 表面及敌方屏障)), 0.500);
			End;
			等待(0.500, 无视条件);
		End;
	}
}

规则("美-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		美;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家, 冰冻, 0.600);
		设置启用终极技能(事件玩家, 假);
		事件玩家.mei_Q_pos = 所选位置(事件玩家);
		事件玩家.mei_Q_timer = 总计消耗时间;
		事件玩家.mei_Q_dec = 面朝方向(事件玩家);
		事件玩家.mei_Q_pos = 矢量(X方向分量(事件玩家.mei_Q_pos) + X方向分量(事件玩家.mei_Q_dec) * 2, Y方向分量(事件玩家.mei_Q_pos), Z方向分量(事件玩家.mei_Q_pos) + Z方向分量(
			事件玩家.mei_Q_dec) * 2);
		While(总计消耗时间 - 事件玩家.mei_Q_timer <= 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-5, 5), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-5, 5)), 矢量(0, -20,
				0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8)), 矢量(0, -20,
				0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8)), 矢量(0, -20,
				0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			事件玩家.mei_Q_pos = 矢量(X方向分量(事件玩家.mei_Q_pos) + X方向分量(事件玩家.mei_Q_dec) * 0.200, Y方向分量(事件玩家.mei_Q_pos), Z方向分量(事件玩家.mei_Q_pos) + Z方向分量(
				事件玩家.mei_Q_dec) * 0.200);
			等待(0.050, 无视条件);
		End;
		设置终极技能充能(事件玩家, 0);
		设置启用终极技能(事件玩家, 真);
	}
}

规则("美-Q-暴击")
{
	事件
	{
		玩家造成伤害;
		双方;
		美;
	}

	条件
	{
		事件技能 == 0;
		事件暴击 == 真;
	}

	动作
	{
		设置状态(被攻击方, 事件玩家, 冰冻, 3);
	}
}

规则("猎空-能量")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy + 事件玩家.tracer_hit > 0;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("{0} - {1}", 事件玩家.tracer_energy, 事件玩家.tracer_hit), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.tracer_energy_text = 上一个文本ID;
	}
}

规则("猎空-能量")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy + 事件玩家.tracer_hit <= 0;
		事件玩家.tracer_energy_text != 0;
	}

	动作
	{
		消除HUD文本(事件玩家.tracer_energy_text);
		事件玩家.tracer_energy_text = 0;
	}
}

规则("猎空-左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
		事件玩家.tracer_energy < 60;
		事件玩家.tracer_energy_reset == 0;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真 && 事件玩家.tracer_energy < 60);
			事件玩家.tracer_energy += 1;
			等待(0.100, 无视条件);
		End;
	}
}

规则("猎空-左键-冷却")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) != 真;
		事件玩家.tracer_energy < 60;
		事件玩家.tracer_energy_reset == 0;
		事件玩家.tracer_energy > 0;
	}

	动作
	{
		等待直到 (正在使用主要武器(事件玩家), 3);
		While(正在使用主要武器(事件玩家) != 真 && 事件玩家.tracer_energy < 60 && 事件玩家.tracer_energy > 0);
			事件玩家.tracer_energy -= 1;
			等待(0.200, 无视条件);
		End;
	}
}

规则("猎空-左键-过热")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy >= 60;
	}

	动作
	{
		设置弹药(事件玩家, 0, 0);
		事件玩家.tracer_energy_reset = 总计消耗时间;
		While(事件玩家.tracer_energy >= 60 && 事件玩家.tracer_energy_reset != 0 && 总计消耗时间 - 事件玩家.tracer_energy_reset <= 1.800);
			等待(0.300, 无视条件);
			设置弹药(事件玩家, 0, 0);
		End;
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
		事件玩家.tracer_energy_reset = 0;
	}
}

规则("猎空-记录")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	动作
	{
		While(所用英雄(事件玩家) == 英雄(猎空));
			等待(3, 当为“假”时中止);
			事件玩家.tracer_energy_last = 事件玩家.tracer_energy;
			事件玩家.tracer_hit_last = 事件玩家.tracer_hit;
		End;
	}
}

规则("猎空-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 较小(事件玩家.tracer_energy, 事件玩家.tracer_energy_last);
	}
}

规则("猎空-左键-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		猎空;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		事件玩家.tracer_hit <= 150;
	}

	动作
	{
		事件玩家.tracer_curr_hit = 生命值(被攻击方) * 0.050;
		伤害(被攻击方, 攻击方, 事件玩家.tracer_curr_hit);
		If((具有状态(被攻击方, 沉睡) || 具有状态(被攻击方, 冰冻) || 具有状态(被攻击方, 击倒) || 具有状态(被攻击方, 击晕) || 具有状态(被攻击方, 被入侵)) == 真);
			中止;
		End;
		事件玩家.tracer_hit += 事件玩家.tracer_curr_hit;
	}
}

规则("猎空-换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家.tracer_energy + 事件玩家.tracer_hit > 0;
	}

	动作
	{
		事件玩家.tracer_energy = 999;
		事件玩家.tracer_hit = 999;
	}
}

规则("猎空-重生")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		在重生室中(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
	}
}

规则("源氏-S")
{
	事件
	{
		玩家造成伤害;
		双方;
		源氏;
	}

	条件
	{
		事件技能 == 按钮(技能1);
	}

	动作
	{
		设置状态(被攻击方, 事件玩家, 燃烧, 1.500);
		开始持续伤害(被攻击方, 事件玩家, 1.500, (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.100);
	}
}

规则("源氏-增伤")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 100, 假, 真);
		事件玩家.genji_pool = 最后创建的生命池;
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家, 150, 无);
		事件玩家.genji_demage = 上一个伤害调整ID;
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 50, 无);
		事件玩家.genji_reduce = 上一个伤害调整ID;
		等待直到 (正在使用终极技能(事件玩家) != 真, 10);
		停止伤害调整(事件玩家.genji_demage);
		事件玩家.genji_demage = 空;
		停止伤害调整(事件玩家.genji_reduce);
		事件玩家.genji_reduce = 空;
		等待(5, 无视条件);
		移除玩家的生命池(事件玩家.genji_pool);
		事件玩家.genji_pool = 空;
	}
}

规则("源氏-增伤-删除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.genji_pool != 空 || 事件玩家.genji_reduce != 空 || 事件玩家.genji_demage != 空 || 事件玩家.genji_e_pool != 空) == 真;
		所用英雄(事件玩家) != 英雄(源氏);
	}

	动作
	{
		If(事件玩家.genji_demage != 空);
			停止伤害调整(事件玩家.genji_demage);
			事件玩家.genji_demage = 空;
		End;
		If(事件玩家.genji_reduce != 空);
			停止伤害调整(事件玩家.genji_reduce);
			事件玩家.genji_reduce = 空;
		End;
		If(事件玩家.genji_pool != 空);
			移除玩家的生命池(事件玩家.genji_pool);
			事件玩家.genji_pool = 空;
		End;
		If(事件玩家.genji_e_pool != 空);
			移除玩家的生命池(事件玩家.genji_e_pool);
			事件玩家.genji_e_pool = 空;
		End;
	}
}

规则("源氏-E-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.genji_e_pool == 空;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 50, 假, 假);
		事件玩家.genji_e_pool = 最后创建的生命池;
		等待(5, 无视条件);
		移除玩家的生命池(事件玩家.genji_e_pool);
		事件玩家.genji_e_pool = 空;
	}
}

规则("破坏球-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		破坏球;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.wrecking_ball_players = 范围内玩家(事件玩家, 8, 所在队伍(事件玩家), 表面及敌方屏障);
		开始伤害调整(事件玩家.wrecking_ball_players, 所有玩家(所在队伍(事件玩家)), 60, 无);
		事件玩家.wrecking_ball_dec_id = 上一个伤害调整ID;
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 事件玩家;
		等待(5, 无视条件);
		停止伤害调整(事件玩家.wrecking_ball_dec_id);
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 0;
	}
}

规则("破坏球-减伤")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件玩家.wrecking_ball_dec != 0;
		攻击方 != 空;
	}

	动作
	{
		伤害(事件玩家.wrecking_ball_dec, 攻击方, 事件伤害 * 0.500);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(白色), 事件玩家, 1);
	}
}

规则("布里吉塔-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.buligita_players = 范围内玩家(事件玩家, 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
		设置状态(事件玩家.buligita_players, 事件玩家, 无敌, 0.300);
		开始伤害调整(事件玩家.buligita_players, 所有玩家(所有队伍), 85, 受伤害者，伤害者及伤害百分比);
		创建效果(所有玩家(所有队伍), 火花, 颜色(黄色), 事件玩家, 8, 位置和半径);
		事件玩家.buligita_light = 最后创建的实体;
		While(正在使用终极技能(事件玩家) == 真);
			设置移动速度(事件玩家.buligita_players, 100);
			事件玩家.buligita_players = 范围内玩家(事件玩家, 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
			设置移动速度(事件玩家.buligita_players, 120);
			等待直到 (正在使用终极技能(事件玩家) != 真, 0.300);
		End;
		设置移动速度(事件玩家.buligita_players, 100);
		停止伤害调整(事件玩家.buligita_dec_id);
		事件玩家.buligita_dec_id = 空;
		消除效果(事件玩家.buligita_light);
		事件玩家.buligita_light = 空;
		事件玩家.buligita_players = 空;
	}
}

规则("debug")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		If(事件玩家.debug_robot == 空);
			创建HUD文本(事件玩家, 事件玩家.debug_2, 正在使用辅助武器(事件玩家), 技能资源(事件玩家, 按钮(跳跃)), 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			生成机器人(英雄(D.Va), 对方队伍(所在队伍(事件玩家)), -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(布丽吉塔), 对方队伍(所在队伍(事件玩家)), -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(死神), 对方队伍(所在队伍(事件玩家)), -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(奥丽莎), 对方队伍(所在队伍(事件玩家)), -1, 事件玩家, 矢量(0, 0, 0));
			事件玩家.debug_robot = 最后创建的实体;
		Else;
			传送(所有玩家(所有队伍), 事件玩家);
		End;
		等待(1, 无视条件);
		设置终极技能充能(事件玩家.debug_robot, 100);
		等待(1, 无视条件);
		按下按键(事件玩家.debug_robot, 按钮(终极技能));
	}
}

规则("debug_hit")
{
	事件
	{
		玩家造成伤害;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		事件玩家.debug_2 = 字符串("{0} - {1}", 事件伤害, 事件技能, 空);
	}
}

规则("奥丽莎-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		奥丽莎;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		施加推力(范围内玩家(事件玩家, 9, 对方队伍(所在队伍(事件玩家)), 表面及敌方屏障), 矢量(0, 1, 0), 8, 至地图, 取消相反运动);
		事件玩家.orisa_teammates = 从数组中移除(范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
		开始伤害调整(事件玩家.orisa_teammates, 所有玩家(对方队伍(所在队伍(事件玩家))), 60, 受伤害者，伤害者及伤害百分比);
		事件玩家.orisa_reduce = 上一个伤害调整ID;
		While(正在使用终极技能(事件玩家) == 真);
			事件玩家.orisa_teammates.orisa_master = 空;
			事件玩家.orisa_teammates = 从数组中移除(范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
			事件玩家.orisa_teammates.orisa_master = 事件玩家;
			等待直到 (正在使用终极技能(事件玩家) != 真, 1);
		End;
		事件玩家.orisa_teammates.orisa_master = 空;
		停止伤害调整(事件玩家.orisa_reduce);
		事件玩家.orisa_reduce = 空;
		事件玩家.orisa_teammates = 空;
	}
}

规则("奥丽莎-Q-吸收伤害")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件玩家.orisa_master != 空;
		正在使用终极技能(事件玩家.orisa_master) == 真;
		所在队伍(被攻击方) != 所在队伍(攻击方);
	}

	动作
	{
		伤害(事件玩家.orisa_master, 攻击方, 事件伤害 * 0.666);
		播放效果(从数组中移除(所有玩家(所有队伍), 事件玩家.orisa_master), 有害爆炸, 颜色(灰绿色), 事件玩家.orisa_master, 1);
	}
}

规则("卢西奥-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置引力(事件玩家, 500);
		等待直到 (正在使用终极技能(事件玩家) != 真, 1);
		设置引力(事件玩家, 100);
		If(正在使用终极技能(事件玩家) == 真 && 存活(事件玩家) == 真);
			范围内玩家(事件玩家, 30, 所在队伍(事件玩家), 表面及敌方屏障).lucio_debuff_clear = 真;
		Else;
	}
}

规则("卢西奥-Q-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
	}

	动作
	{
		等待(6, 无视条件);
		事件玩家.lucio_debuff_clear = 假;
	}
}

规则("卢西奥-Q-负面状态清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
		(具有状态(事件玩家, 冰冻) || 具有状态(事件玩家, 击倒) || 具有状态(事件玩家, 击晕) || 具有状态(事件玩家, 沉睡) || 具有状态(事件玩家, 燃烧) || 具有状态(事件玩家, 被入侵)) == 真;
	}

	动作
	{
		清除状态(事件玩家, 冰冻);
		清除状态(事件玩家, 沉睡);
		清除状态(事件玩家, 燃烧);
		清除状态(事件玩家, 击倒);
		清除状态(事件玩家, 击晕);
		清除状态(事件玩家, 被入侵);
		等待(0.100, 无视条件);
		清除状态(事件玩家, 冰冻);
		清除状态(事件玩家, 沉睡);
		清除状态(事件玩家, 燃烧);
		清除状态(事件玩家, 击倒);
		清除状态(事件玩家, 击晕);
		清除状态(事件玩家, 被入侵);
	}
}

规则("卢西奥-被动-滑墙")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		在墙上(事件玩家) == 真;
		在地面上(事件玩家) != 真;
	}

	动作
	{
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 90, 受伤害者和伤害者);
		事件玩家.lucio_slice_dec = 上一个伤害调整ID;
	}
}

规则("卢西奥-被动-滑墙-解除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_slice_dec != 空;
		(所用英雄(事件玩家) != 英雄(卢西奥) || 在墙上(事件玩家) != 真 || 在地面上(事件玩家)) == 真;
	}

	动作
	{
		停止伤害调整(事件玩家.lucio_slice_dec);
		事件玩家.lucio_slice_dec = 0;
	}
}

规则("卢西奥-E-强化强音")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.lucio_e_inc != 空;
	}

	动作
	{
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 范围内玩家(事件玩家, 12, 所在队伍(事件玩家), 表面及敌方屏障), 115, 无);
		事件玩家.lucio_e_inc = 上一个伤害调整ID;
		等待(3, 无视条件);
		停止伤害调整(事件玩家.lucio_e_inc);
		事件玩家.lucio_e_inc = 空;
	}
}

规则("卢西奥-E-强化强音-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_e_inc != 空;
		英雄(卢西奥) != 所用英雄(事件玩家);
	}

	动作
	{
		停止伤害调整(事件玩家.lucio_e_inc);
		事件玩家.lucio_e_inc = 空;
	}
}

规则("黑影-伤害")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(黑影);
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(主要攻击模式)) == 真;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		If(事件玩家.sombra_player == 空);
			事件玩家.sombra_player = 攻击方;
			事件玩家.sombra_demage = 事件伤害;
			事件玩家.sombra_timer = 3;
		Else If(事件玩家.sombra_player == 攻击方);
			事件玩家.sombra_demage += 事件伤害;
			事件玩家.sombra_timer = 3;
		Else;
			中止;
		End;
		If(事件玩家.sombra_demage > 最大生命值(事件玩家) * 0.500);
			设置状态(事件玩家, 事件玩家.sombra_player, 被入侵, 3);
			事件玩家.sombra_hacked = 真;
			事件玩家.sombra_timer = 0;
			事件玩家.sombra_player = 空;
			事件玩家.sombra_demage = 0;
			等待(8, 无视条件);
			事件玩家.sombra_hacked = 假;
		End;
	}
}

规则("黑影-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sombra_player != 空;
		事件玩家.sombra_demage > 0;
		事件玩家.sombra_timer > 0;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		While(事件玩家.sombra_timer > 0);
			等待直到 (事件玩家.sombra_timer <= 0, 1);
			事件玩家.sombra_timer -= 1;
		End;
		事件玩家.sombra_player = 空;
		事件玩家.sombra_demage = 0;
	}
}

规则("布里吉塔-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用辅助武器(事件玩家) != 真, 1.500);
		创建效果(所有玩家(所有队伍), 环, 自定义颜色(248, 213, 97, 171), 事件玩家, 10, 可见，位置和半径);
		事件玩家.buligita_heal_ring = 最后创建的实体;
		While(正在使用辅助武器(事件玩家) == 真);
			开始持续治疗(范围内玩家(事件玩家, 10, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家, 0.500, 10);
			等待直到 (正在使用辅助武器(事件玩家) != 真, 0.500);
		End;
		消除效果(事件玩家.buligita_heal_ring);
		事件玩家.buligita_heal_ring = 空;
	}
}

规则("布丽吉塔-基础生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		事件玩家.buligita_base_armor == 空;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 护甲, 50, 真, 假);
		事件玩家.buligita_base_armor = 最后创建的生命池;
	}
}

规则("布丽吉塔-基础生命-删除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.buligita_base_armor != 空;
		所用英雄(事件玩家) != 英雄(布丽吉塔);
	}

	动作
	{
		移除玩家的生命池(事件玩家.buligita_base_armor);
		事件玩家.buligita_base_armor = 空;
	}
}

规则("死神-被动-暗影")
{
	事件
	{
		玩家受到伤害;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) != 真;
		全局.random <= 0.100;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家, 相移, 0.500);
		等待(0.500, 无视条件);
	}
}

规则("死神-主武器-坦克杀手")
{
	事件
	{
		玩家造成伤害;
		双方;
		死神;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		数组包含(所有重装英雄, 所用英雄(被攻击方)) == 真;
	}

	动作
	{
		If(类型的生命值(被攻击方, 护甲) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.300);
		Else If(类型的生命值(被攻击方, 护盾) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.200);
		Else;
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.100);
		End;
	}
}

规则("死神-S-暗影")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待(0.410, 无视条件);
		设置状态(事件玩家, 事件玩家, 相移, 2);
		开始按下按钮(事件玩家, 按钮(技能1));
		等待直到 (正在使用技能 1(事件玩家) != 真, 3);
		停止按下按钮(事件玩家, 按钮(技能1));
		禁用按钮(事件玩家, 按钮(终极技能));
	}
}

规则("死神-暗影-特效")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) == 真;
		事件玩家.reaper_shadow == 空;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 云, 颜色(紫色), 事件玩家, 1.500, 可见，位置和半径);
		事件玩家.reaper_shadow = 最后创建的实体;
	}
}

规则("死神-暗影-特效-消除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(英雄(死神) != 所用英雄(事件玩家) || 具有状态(事件玩家, 相移) != 真) == 真;
		事件玩家.reaper_shadow != 空;
	}

	动作
	{
		可用按钮(事件玩家, 按钮(终极技能));
		消除效果(事件玩家.reaper_shadow);
		事件玩家.reaper_shadow = 空;
	}
}

规则("DVA-被暴击")
{
	事件
	{
		玩家受到伤害;
		双方;
		D.Va;
	}

	条件
	{
		事件暴击 == 真;
		处于非初始状态(事件玩家) != 真;
		事件玩家.dva_clear_flag != 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 较大(事件伤害 * 0.400, 8), 假, 真);
		事件玩家.dva_pools_list = 添加至数组(事件玩家.dva_pools_list, 最后创建的生命池);
		If(数量(事件玩家.dva_pools_list) > 60);
			事件玩家.dva_hp_pool = 事件玩家.dva_pools_list[0];
			移除玩家的生命池(事件玩家.dva_hp_pool);
			事件玩家.dva_pools_list = 从数组中移除(事件玩家.dva_pools_list, 事件玩家.dva_hp_pool);
		End;
		事件玩家.dva_timer = 5;
	}
}

规则("DVA-护盾清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.dva_pools_list != 空;
		数量(事件玩家.dva_pools_list) > 0;
		(所用英雄(事件玩家) != 英雄(D.Va) || 处于非初始状态(事件玩家) || 事件玩家.dva_timer <= 0) == 真;
		事件玩家.dva_clear_flag != 真;
	}

	动作
	{
		事件玩家.dva_clear_flag = 真;
		事件玩家.dva_timer = 0;
		For 玩家变量(事件玩家, dva_pool_idx, 0, 数量(事件玩家.dva_pools_list), 1);
			事件玩家.dva_hp_pool = 事件玩家.dva_pools_list[事件玩家.dva_pool_idx];
			移除玩家的生命池(事件玩家.dva_hp_pool);
		End;
		事件玩家.dva_pools_list = 空数组;
		事件玩家.dva_clear_flag = 假;
	}
}

规则("DVA-护盾定时清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		事件玩家.dva_timer > 0;
		事件玩家.dva_clear_flag != 真;
	}

	动作
	{
		While(事件玩家.dva_timer > 0);
			等待(1, 无视条件);
			事件玩家.dva_timer -= 1;
		End;
	}
}

规则("DVA-被动-飞行矩阵回复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		While(正在使用技能 1(事件玩家) == 真);
			设置技能资源(事件玩家, 按钮(辅助攻击模式), 2 + 技能资源(事件玩家, 按钮(辅助攻击模式)));
			等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		End;
	}
}

规则("巴蒂斯特-S-临时生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, (最大生命值(事件玩家) - 生命值(事件玩家)) * 0.400, 假, 假);
		事件玩家.baptiste_shift_hp = 最后创建的生命池;
		等待(3, 无视条件);
		移除玩家的生命池(事件玩家.baptiste_shift_hp);
	}
}

规则("巴蒂斯特-主武器-附加伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		巴蒂斯特;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		伤害(被攻击方, 攻击方, 生命值(被攻击方) * 0.040);
	}
}

规则("巴蒂斯特-副武器-双发扳机")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待(0.050, 无视条件);
		创建弹道(巴蒂斯特生化榴弹枪, 事件玩家, 眼睛位置(事件玩家), 面朝方向(事件玩家), 至地图, 治疗, 所在队伍(事件玩家), 50, 0.700, 3, 有益爆炸, 巴蒂斯特生化榴弹枪爆炸声音, 0, 60, 2, 0, 0, 20);
		等待直到 (正在使用辅助武器(事件玩家) != 真, 0.500);
		设置弹药(事件玩家, 1, 弹药(事件玩家, 1) - 1);
	}
}

规则("西格玛-Q-炮塔放置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		等待(0.500, 无视条件);
		If(存活(事件玩家) && 正在使用终极技能(事件玩家) != 真 && 具有状态(事件玩家, 被入侵) != 真);
			中止;
		End;
		事件玩家.sigma_battery_pos = 眼睛位置(事件玩家);
		创建效果(所有玩家(所在队伍(事件玩家)), 球, 颜色(蓝色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 数组(最后创建的实体);
		创建效果(所有玩家(对方队伍(所在队伍(事件玩家))), 球, 颜色(红色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 添加至数组(事件玩家.sigma_battery_pic, 最后创建的实体);
		等待(8, 无视条件);
		事件玩家.sigma_battery_pos = 空;
		消除效果(事件玩家.sigma_battery_pic[0]);
		消除效果(事件玩家.sigma_battery_pic[1]);
		事件玩家.sigma_battery_pic = 空;
	}
}

规则("西格玛-Q-炮塔攻击")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		事件玩家.sigma_battery_pos != 空;
	}

	动作
	{
		While(事件玩家.sigma_battery_pos != 空);
			事件玩家.sigma_battery_target = 已排序的数组(范围内玩家(事件玩家.sigma_battery_pos, 15, 对方队伍(所在队伍(事件玩家)), 表面), (存活(当前数组元素) && !具有状态(事件玩家, 无敌) && !具有状态(事件玩家, 相移)) ? 标准化生命值(当前数组元素) - (
				正在空中(当前数组元素) && !正在跳跃(当前数组元素) ? (标准化生命值(当前数组元素) >= 0.500 ? 1 : -1) : 0) : 9999)[0];
			If(事件玩家.sigma_battery_target != 空 && 存活(事件玩家.sigma_battery_target));
				If(正在空中(事件玩家.sigma_battery_target) && !正在跳跃(事件玩家.sigma_battery_target));
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						60, 0.300, 3, 有害爆炸, 爆炸声音, 0, 96, 0.156, 1.100, 0, 0);
					等待(0.335, 无视条件);
				Else;
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						30, 0.300, 3, 有害爆炸, 爆炸声音, 0, 48, 0.312, 1.100, 0, 0);
					等待(0.670, 无视条件);
				End;
			Else;
				等待(0.050, 无视条件);
			End;
		End;
		事件玩家.sigma_battery_target = 空;
	}
}

规则("安娜-被动-治疗护盾")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(安娜);
		受治疗者.ana_healing == 空;
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 50, 假, 假);
		受治疗者.ana_healing = 最后创建的生命池;
		等待(1.500, 无视条件);
		移除玩家的生命池(受治疗者.ana_healing);
		受治疗者.ana_healing = 空;
	}
}

规则("安娜-E-禁疗强化")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(安娜);
	}

	动作
	{
		事件玩家.ana_healing_preventing = 2;
		等待(3, 无视条件);
		事件玩家.ana_healing_preventing = 1;
		等待(2, 无视条件);
		事件玩家.ana_healing_preventing = 0;
	}
}

规则("安娜-E-禁疗状态")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ana_healing_preventing == 2;
	}

	动作
	{
		开始治疗调整(事件玩家, 所有玩家(所在队伍(事件玩家)), 50, 全部禁用);
		事件玩家.ana_healing_preventing_status = 上一个治疗调整ID;
	}
}

规则("安娜-E-禁疗清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ana_healing_preventing == 0;
	}

	动作
	{
		停止治疗调整(事件玩家.ana_healing_preventing_status);
	}
}

规则("卡西迪-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		卡西迪;
	}

	条件
	{
		事件玩家.cassidy_clear_flag != 真;
	}

	动作
	{
		If(类型的生命值(事件玩家, 生命值) - 225 <= 100);
			为玩家添加生命池(事件玩家, 生命值, 事件伤害 * 0.250, 假, 假);
			事件玩家.cassidy_pools_list = 添加至数组(事件玩家.cassidy_pools_list, 最后创建的生命池);
			If(数量(事件玩家.cassidy_pools_list) > 10);
				事件玩家.cassidy_hp_pool = 事件玩家.cassidy_pools_list[0];
				移除玩家的生命池(事件玩家.cassidy_hp_pool);
				事件玩家.cassidy_pools_list = 从数组中移除(事件玩家.cassidy_pools_list, 事件玩家.cassidy_hp_pool);
			End;
		End;
		事件玩家.cassidy_timer = 3;
	}
}

规则("卡西迪-护盾清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.cassidy_pools_list != 空;
		数量(事件玩家.cassidy_pools_list) > 0;
		(所用英雄(事件玩家) != 英雄(卡西迪) || 事件玩家.cassidy_timer <= 0) == 真;
		事件玩家.cassidy_clear_flag != 真;
	}

	动作
	{
		事件玩家.cassidy_clear_flag = 真;
		事件玩家.cassidy_timer = 0;
		For 玩家变量(事件玩家, cassidy_pool_idx, 0, 数量(事件玩家.cassidy_pools_list), 1);
			事件玩家.cassidy_hp_pool = 事件玩家.cassidy_pools_list[事件玩家.cassidy_pool_idx];
			移除玩家的生命池(事件玩家.cassidy_hp_pool);
		End;
		事件玩家.cassidy_pools_list = 空数组;
		事件玩家.cassidy_clear_flag = 假;
	}
}

规则("卡西迪-护盾定时清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卡西迪;
	}

	条件
	{
		事件玩家.cassidy_timer > 0;
		事件玩家.cassidy_clear_flag != 真;
	}

	动作
	{
		While(事件玩家.cassidy_timer > 0);
			等待(1, 无视条件);
			事件玩家.cassidy_timer -= 1;
		End;
	}
}

规则("末日铁拳-被动-无损蓄力-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.doomfist_pool == 空;
		事件玩家.ana_healing < 2;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 200, 假, 假);
		事件玩家.doomfist_pool = 最后创建的生命池;
		等待直到 (按钮被按下(事件玩家, 按钮(辅助攻击模式)) != 真 || 正在使用辅助武器(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		移除玩家的生命池(事件玩家.doomfist_pool);
		事件玩家.doomfist_pool = 空;
	}
}

规则("末日铁拳-被动-无损蓄力-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		事件玩家.doomfist_pool == 空;
		事件玩家.ana_healing < 2;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 200, 假, 假);
		事件玩家.doomfist_pool = 最后创建的生命池;
		等待直到 (正在使用技能 2(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		移除玩家的生命池(事件玩家.doomfist_pool);
		事件玩家.doomfist_pool = 空;
	}
}

规则("末日铁拳-被动-无损蓄力-S")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		事件玩家.doomfist_pool == 空;
		事件玩家.ana_healing < 2;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 200, 假, 假);
		事件玩家.doomfist_pool = 最后创建的生命池;
		等待直到 (正在使用技能 1(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		移除玩家的生命池(事件玩家.doomfist_pool);
		事件玩家.doomfist_pool = 空;
	}
}

规则("末日铁拳-被动-无损蓄力-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.doomfist_pool != 空;
		(所用英雄(事件玩家) != 英雄(末日铁拳)) == 真;
	}

	动作
	{
		移除玩家的生命池(事件玩家.doomfist_pool);
		事件玩家.doomfist_pool = 空;
	}
}

规则("艾什-主武器-霰弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
		创建弹道(“天使”天使冲击枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
			2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.050, 0, 0, 0);
	}
}

规则("禅雅塔-S-附加护甲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		移除玩家的生命池(事件玩家.zenyata_shift_armor[1]);
		
		事件玩家.zenyata_shift_armor = 数组(距离准星最近的玩家(事件玩家, 所在队伍(事件玩家)), 0);
		为玩家添加生命池(事件玩家.zenyata_shift_armor[0], 护甲, 25, 真, 假);
		事件玩家.zenyata_shift_armor[1] = 最后创建的生命池;
	}
}

规则("禅雅塔-S-附加护甲")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		英雄(禅雅塔) == 所用英雄(治疗者);
		(事件玩家.zenyata_shift_armor == 空 || 事件玩家.zenyata_shift_armor[1] != 治疗者) == 真;
	}

	动作
	{
		移除玩家的生命池(治疗者.zenyata_shift_armor[1]);
		
		治疗者.zenyata_shift_armor = 数组(受治疗者, 0);
		为玩家添加生命池(治疗者.zenyata_shift_armor[0], 护甲, 25, 真, 假);
		治疗者.zenyata_shift_armor[1] = 最后创建的生命池;
	}
}

规则("禅雅塔-S-清理护甲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.zenyata_shift_armor != 空;
		(英雄(禅雅塔) != 所用英雄(事件玩家) || !正在使用技能 1(事件玩家) || !存活(事件玩家)) == 真;
	}

	动作
	{
		移除玩家的生命池(事件玩家.zenyata_shift_armor[1]);
		事件玩家.zenyata_shift_armor = 空;
	}
}

规则("禅雅塔-E-附加伤害")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		停止持续伤害(事件玩家.zenyata_e_hurt);
		事件玩家.zenyata_e_player = 距离准星最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)));
		等待直到 (正在使用技能 2(事件玩家) != 真, 1);
		While(正在使用技能 2(事件玩家) == 真);
			开始持续伤害(事件玩家.zenyata_e_player, 事件玩家, 0.500, 较大((最大生命值(事件玩家.zenyata_e_player) - 生命值(事件玩家.zenyata_e_player)) * 0.050, 1));
			事件玩家.zenyata_e_hurt = 上一个持续伤害效果ID;
			等待直到 (正在使用技能 2(事件玩家) != 真, 0.500);
		End;
	}
}

规则("索杰恩-主武器-弹速增强")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真);
			设置弹道速度(事件玩家, 100000);
			等待直到 (正在使用主要武器(事件玩家) != 真, 1.5);
			中断;
		End;
		设置弹道速度(事件玩家, 100);
	}
}

规则("温斯顿-副武器-蓄力")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		While((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) == 真);
			等待直到((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) != 真, 0.3);
			事件玩家.winston_power += 2;
		End;
		等待(0.5,无视条件);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-副武器-击退")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		英雄(温斯顿) == 所用英雄(攻击方);
		事件技能 == 按钮(辅助攻击模式);
		攻击方.winston_power > 0;
	}

	动作
	{
		施加推力(被攻击方, 矢量(X方向分量(方向(攻击方, 被攻击方)), 0.25, Z方向分量(方向(攻击方, 被攻击方))), 攻击方.winston_power < 10 ? 攻击方.winston_power * 2 : 攻击方.winston_power + 10, 至地图, 合并相反运动);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-被动-伤害调整")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	条件
	{
		事件玩家.winston_inc == 空;
	}

	动作
	{
		事件玩家.winston_inc = 数组();
		开始伤害调整(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[0] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[1] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[2] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[3] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[4] = 上一个伤害调整ID;
	}
}

规则("温斯顿-被动-伤害清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.winston_inc != 空;
		所用英雄(事件玩家) != 英雄(温斯顿);
	}

	动作
	{
		停止伤害调整(事件玩家.winston_inc[0]);
		停止伤害调整(事件玩家.winston_inc[1]);
		停止伤害调整(事件玩家.winston_inc[2]);
		停止伤害调整(事件玩家.winston_inc[3]);
		停止伤害调整(事件玩家.winston_inc[4]);
		事件玩家.winston_inc = 空;
	}
}
