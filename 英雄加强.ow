设置
{
	模式
	{
		占领要点
		{
			获胜得分: 3
			计分速度: 30%

			禁用地图
			{
				春节漓江塔
			}
		}

		攻击护送
		{
			启用地图
			{
			}
		}

		机动推进
		{
			启用地图
			{
			}
		}

		运载目标
		{
			启用地图
			{
			}
		}

		闪点作战
		{
			获胜得分: 10
			计分速度: 30%

			启用地图
			{
			}
		}

		综合
		{
			职责限制: 1重装，2输出，2支援
		}
	}

	英雄
	{
		综合
		{
			死神
			{
				幽灵形态 冷却时间: 125%
			}

			猎空
			{
				无需装弹: 开启
			}

			艾什
			{
				延时雷管引爆时间: 1%
			}
		}
	}

	扩展
	{
		爆炸声音
		弹道
	}
}

变量
{
	全局:
		0: random

		1: t_enum_hp_pool
		2: t_enum_damage_adjust
		3: t_enum_heal_adjust
		4: t_enum_effect
		5: t_enum_speed
		6: t_enum_move_cd

		20: ci_tracer_max_energy
		21: ci_doomfist_hp_size

	玩家:
		0: d_sys_cd
		1: i_sys_pre_speed
		2: i_sys_speed
		3: tracer_energy
		4: tracer_energy_reset
		5: tracer_energy_text
		6: tracer_energy_last
		7: tracer_hit
		8: tracer_hit_last
		9: tracer_curr_hit
		10: genji_reduce
		11: genji_demage
		12: genji_pool
		13: genji_flag
		15: sys_cd_flag
		16: mei_Q_timer
		17: mei_Q_pos
		18: mei_Q_dec
		19: reaper_shadow
		20: buligita_players
		21: roadhog_mates_flag
		25: ana_healing_preventing
		26: ana_healing_preventing_status
		30: lucio_debuff_clear
		31: lucio_slice_dec
		32: lucio_players
		35: soldier76_angle
		36: soldier76_players
		40: sombra_demage
		41: sombra_timer
		42: sombra_player
		43: sombra_hacked
		45: dva_armor_recover
		50: wrecking_ball_dec
		51: wrecking_ball_players
		52: wrecking_ball_dec_id
		60: orisa_teammates
		61: orisa_reduce
		63: orisa_master
		65: sigma_battery_pos
		66: sigma_battery_pic
		67: sigma_battery_target
		70: baptiste_shift_hp
		75: zenyata_shift_armor
		76: zenyata_e_player
		77: zenyata_target
		78: zenyata_shift_flag
		80: winston_power
		81: winston_inc
		85: zarya_hp_record
		86: zarya_hp_record_tmp
		87: zarya_weaken
		88: zarya_heal_inc
		90: sojourn_Q_demage_count
		91: sojourn_bullet_count
		95: symmetra_Q_effect
		96: symmetra_Q_players
		97: symmetra_Q_inedx
		110: junkerqueen_effect
		111: junkerqueen_timer
		120: widowmaker_hp_pool
		121: widowmaker_hp_pool_timer
		100: debug_robot
		101: debug_1
		102: debug_2

		103: sys_data_record

		105: sys_default_status_pool
		107: sys_default_status_pool_i

		106: sys_players_record
		108: sys_status_thorns
		109: sys_self_text
}

子程序
{
	0: remove_default_status
}

规则("常量")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.ci_tracer_max_energy = 50;

		全局.t_enum_hp_pool = 1;
		全局.t_enum_damage_adjust = 2;
		全局.t_enum_heal_adjust = 3;
		全局.t_enum_effect = 4;
		全局.t_enum_speed = 5;
	}
}

规则("随机数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		While(真);
			全局.random = 随机实数(0, 1);
			等待(0, 无视条件);
		End;
	}
}

规则("状态显示文本")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		创建HUD文本(数量(事件玩家.sys_status_thorns) > 0 ? 事件玩家 : 空, 自定义字符串(""), 自定义字符串("荆棘：{0}%", 事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns) - 1][0] * 100), 自定义字符串(""), 右边, 0, 颜色(白色), 颜色(绿色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("状态清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sys_status_thorns != 空;
		数量(事件玩家.sys_status_thorns) > 0;
	}

	动作
	{
		While(真);
			// 等待直到(数量(事件玩家.sys_status_thorns) > 0, 99999);
			等待(0.100, 无视条件);
			If(数量(事件玩家.sys_status_thorns) > 0);
				事件玩家.sys_status_thorns = 已排序的数组(已过滤的数组(事件玩家.sys_status_thorns, (当前数组元素[1] < 0 || 当前数组元素[2] < 0) ? (当前数组元素[3] == 空 || 所用英雄(事件玩家) == 当前数组元素[3]) : (((总计消耗时间 - 当前数组元素[1]) <= 当前数组元素[2]) && (当前数组元素[3] == 空 || 所用英雄(事件玩家) == 当前数组元素[3]))), 当前数组元素[0]);
			End;
		End;
	}
}

规则("玩家状态-荆棘")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		数量(被攻击方.sys_status_thorns) > 0;
		数量(攻击方.sys_status_thorns) <= 0;
	}

	动作
	{
		伤害(攻击方, 被攻击方, 事件伤害 * 被攻击方.sys_status_thorns[数量(被攻击方.sys_status_thorns) - 1][0]);
		If(截取字符串(被攻击方.sys_status_thorns[数量(被攻击方.sys_status_thorns) - 1][4], 0, 字符串长度(自定义字符串("Junker Queen"))) == 自定义字符串("Junker Queen"));
			被攻击方.sys_status_thorns[数量(被攻击方.sys_status_thorns) - 1][5].sys_data_record[1] += 事件伤害 * 被攻击方.sys_status_thorns[数量(被攻击方.sys_status_thorns) - 1][0];
		End;
	}
}

规则("资源回收执行")
{
	事件
	{
		子程序;
		remove_default_status;
	}

	动作
	{
		If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_hp_pool);
			移除玩家的生命池(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_damage_adjust);
			停止伤害调整(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_heal_adjust);
			停止治疗调整(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_effect);
			消除效果(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_speed);
			事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0].i_sys_speed -= 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1];
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_move_cd);
			事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0].d_sys_cd -= 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1];
		End;
		事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i] = 空;
	}
}

规则("系统资源回收")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待直到(数量(事件玩家.sys_default_status_pool) > 0, 99999);
			等待(0.050, 无视条件);
			For 玩家变量(事件玩家, sys_default_status_pool_i, 0, 数量(事件玩家.sys_default_status_pool), 1);
				If(数量(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i]) == 2);
					调用子程序(remove_default_status);
				Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][4] == 空 || 所用英雄(事件玩家) == 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][4]);
					If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][2] >= 0 && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][3] >= 0 && (总计消耗时间 - 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][2]) > 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][3]);
						调用子程序(remove_default_status);
					End;
				Else;
					调用子程序(remove_default_status);
				End;
			End;
			事件玩家.sys_default_status_pool = 已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素 != 空 && 数量(当前数组元素) > 1);
		End;
	}
}

规则("全局定时器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			If(事件玩家.junkerqueen_timer > 0);
				事件玩家.junkerqueen_timer -= 0.1;
			Else;
				事件玩家.junkerqueen_timer = 0.0;
			End;
			If(事件玩家.widowmaker_hp_pool_timer > 0);
				事件玩家.widowmaker_hp_pool_timer -= 0.1;
			Else;
				事件玩家.widowmaker_hp_pool_timer = 0.0;
			End;
			If(事件玩家.genji_flag > 0);
				事件玩家.genji_flag -= 0.1;
			Else;
				事件玩家.genji_flag = 0.0;
			End;
			等待(0.100, 无视条件);
		End;
	}
}

规则("个人文本烂")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待(0.500, 无视条件);

			If(事件玩家.sys_self_text != 空 && 所用英雄(事件玩家) != 事件玩家.sys_self_text[0]);
				消除HUD文本(事件玩家.sys_self_text[1]);
				事件玩家.sys_self_text = 空;
			End;
		End;
	}
}

规则("个人数据面板")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.sys_data_record == 空 || 数量(事件玩家.sys_data_record) <= 0 || 所用英雄(事件玩家) != 事件玩家.sys_data_record[0]) == 真;
	}

	动作
	{
		事件玩家.sys_data_record = 数组(所用英雄(事件玩家));
	}
}

规则("sys_speed")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待直到(事件玩家.i_sys_pre_speed != 事件玩家.i_sys_speed, 9999);
			// 设置移动速度(事件玩家, 较小(较大(100 + 事件玩家.i_sys_speed, 70), 140));
			设置移动速度(事件玩家, 100 + 事件玩家.i_sys_speed);
			事件玩家.i_sys_pre_speed = 事件玩家.i_sys_speed;
		End;
	}
}

规则("sys_cd_1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(技能1)) > 0;
		事件玩家.d_sys_cd > 0;
		事件玩家.sys_cd_flag[0] != 真;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(技能1), 技能冷却时间(事件玩家, 按钮(技能1)) * 较大(0.6, 1 - 事件玩家.d_sys_cd));
		事件玩家.sys_cd_flag[0] = 真;
	}
}

规则("sys_cd_1_flag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(技能冷却时间(事件玩家, 按钮(技能1)) <= 0 || 正在使用技能 1(事件玩家)) == 真;
		事件玩家.sys_cd_flag[0] == 真;
	}

	动作
	{
		事件玩家.sys_cd_flag[0] = 假;
	}
}

规则("sys_cd_2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
		事件玩家.d_sys_cd > 0;
		事件玩家.sys_cd_flag[1] != 真;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(技能2), 技能冷却时间(事件玩家, 按钮(技能2)) * 较大(0.6, 1 - 事件玩家.d_sys_cd));
		事件玩家.sys_cd_flag[1] = 真;
	}
}

规则("sys_cd_2_flag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(技能冷却时间(事件玩家, 按钮(技能2)) <= 0 || 正在使用技能 2(事件玩家)) == 真;
		事件玩家.sys_cd_flag[1] == 真;
	}

	动作
	{
		事件玩家.sys_cd_flag[1] = 假;
	}
}

规则("sys_cd_left")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(主要攻击模式)) > 0;
		事件玩家.d_sys_cd > 0;
		事件玩家.sys_cd_flag[2] != 真;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(主要攻击模式), 技能冷却时间(事件玩家, 按钮(主要攻击模式)) * 较大(0.6, 1 - 事件玩家.d_sys_cd));
		事件玩家.sys_cd_flag[2] = 真;
	}
}

规则("sys_cd_left_flag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(技能冷却时间(事件玩家, 按钮(主要攻击模式)) <= 0 || 正在使用主要武器(事件玩家)) == 真;
		事件玩家.sys_cd_flag[2] == 真;
	}

	动作
	{
		事件玩家.sys_cd_flag[2] = 假;
	}
}

规则("sys_cd_right")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0;
		事件玩家.d_sys_cd > 0;
		事件玩家.sys_cd_flag[3] != 真;
	}

	动作
	{
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 技能冷却时间(事件玩家, 按钮(辅助攻击模式)) * 较大(0.6, 1 - 事件玩家.d_sys_cd));
		事件玩家.sys_cd_flag[3] = 真;
	}
}

规则("sys_cd_right_flag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(技能冷却时间(事件玩家, 按钮(辅助攻击模式)) <= 0 || 正在使用辅助武器(事件玩家)) == 真;
		事件玩家.sys_cd_flag[3] == 真;
	}

	动作
	{
		事件玩家.sys_cd_flag[3] = 假;
	}
}

规则("艾什-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 40, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
	}
}

规则("伊拉锐-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		伊拉锐;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		While(正在使用终极技能(事件玩家) == 真);
			If(空数组 != 范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障));
				创建追踪弹道(巴蒂斯特生化榴弹枪, 事件玩家, 所选位置(事件玩家), 空, 至地图, 治疗, 所在队伍(事件玩家), 50, 0.500, 3, 有益爆炸, 巴蒂斯特生化榴弹枪爆炸声音, 0, 10, 6, 0, 数组随机取值(范围内玩家(事件玩家, 15,
					所在队伍(事件玩家), 表面及敌方屏障)), 0.500);
			End;
			等待(0.500, 无视条件);
		End;
	}
}

规则("美-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		美;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家, 冰冻, 0.600);
		设置启用终极技能(事件玩家, 假);
		事件玩家.mei_Q_pos = 所选位置(事件玩家);
		事件玩家.mei_Q_timer = 总计消耗时间;
		事件玩家.mei_Q_dec = 面朝方向(事件玩家);
		事件玩家.mei_Q_pos = 矢量(X方向分量(事件玩家.mei_Q_pos) + X方向分量(事件玩家.mei_Q_dec) * 2, Y方向分量(事件玩家.mei_Q_pos), Z方向分量(事件玩家.mei_Q_pos) + Z方向分量(
			事件玩家.mei_Q_dec) * 2);
		While(总计消耗时间 - 事件玩家.mei_Q_timer <= 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-5, 5), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-5, 5)), 矢量(0, -20,
				0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8)), 矢量(0, -20,
				0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-8, 8)), 矢量(0, -20,
				0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			创建弹道(美冰锥, 事件玩家, 矢量(X方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10), Y方向分量(事件玩家.mei_Q_pos) + 8, Z方向分量(事件玩家.mei_Q_pos) + 随机实数(-10, 10)), 矢量(0,
				-20, 0), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(5, 15), 6, 0, 0, 10);
			事件玩家.mei_Q_pos = 矢量(X方向分量(事件玩家.mei_Q_pos) + X方向分量(事件玩家.mei_Q_dec) * 0.200, Y方向分量(事件玩家.mei_Q_pos), Z方向分量(事件玩家.mei_Q_pos) + Z方向分量(
				事件玩家.mei_Q_dec) * 0.200);
			等待(0.050, 无视条件);
		End;
		设置终极技能充能(事件玩家, 0);
		设置启用终极技能(事件玩家, 真);
	}
}

规则("美-Q-暴击")
{
	事件
	{
		玩家造成伤害;
		双方;
		美;
	}

	条件
	{
		事件技能 == 0;
		事件暴击 == 真;
	}

	动作
	{
		设置状态(被攻击方, 事件玩家, 冰冻, 3);
	}
}

规则("猎空-能量")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy + 事件玩家.tracer_hit > 0;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("{0} - {1}", 事件玩家.tracer_energy, 事件玩家.tracer_hit), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.tracer_energy_text = 上一个文本ID;
	}
}

规则("猎空-能量")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy + 事件玩家.tracer_hit <= 0;
		事件玩家.tracer_energy_text != 0;
	}

	动作
	{
		消除HUD文本(事件玩家.tracer_energy_text);
		事件玩家.tracer_energy_text = 0;
	}
}

规则("猎空-左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
		事件玩家.tracer_energy < 全局.ci_tracer_max_energy;
		事件玩家.tracer_energy_reset == 0;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真 && 事件玩家.tracer_energy < 全局.ci_tracer_max_energy);
			事件玩家.tracer_energy += 1;
			等待(0.100, 无视条件);
		End;
	}
}

规则("猎空-左键-冷却")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) != 真;
		事件玩家.tracer_energy < 全局.ci_tracer_max_energy;
		事件玩家.tracer_energy_reset == 0;
		事件玩家.tracer_energy > 0;
	}

	动作
	{
		等待直到 (正在使用主要武器(事件玩家), 3);
		While(正在使用主要武器(事件玩家) != 真 && 事件玩家.tracer_energy < 全局.ci_tracer_max_energy && 事件玩家.tracer_energy > 0);
			事件玩家.tracer_energy -= 1;
			等待(0.200, 无视条件);
		End;
	}
}

规则("猎空-左键-过热")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy >= 全局.ci_tracer_max_energy;
	}

	动作
	{
		设置弹药(事件玩家, 0, 0);
		事件玩家.tracer_energy_reset = 总计消耗时间;
		While(事件玩家.tracer_energy >= 全局.ci_tracer_max_energy && 事件玩家.tracer_energy_reset != 0 && 总计消耗时间 - 事件玩家.tracer_energy_reset <= 1.800);
			等待(0.300, 无视条件);
			设置弹药(事件玩家, 0, 0);
		End;
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
		事件玩家.tracer_energy_reset = 0;
	}
}

规则("猎空-记录")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	动作
	{
		While(所用英雄(事件玩家) == 英雄(猎空));
			等待(3, 当为“假”时中止);
			事件玩家.tracer_energy_last = 事件玩家.tracer_energy;
			事件玩家.tracer_hit_last = 事件玩家.tracer_hit;
		End;
	}
}

规则("猎空-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 较小(事件玩家.tracer_energy, 事件玩家.tracer_energy_last);
	}
}

规则("猎空-左键-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		猎空;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		事件玩家.tracer_hit <= 150;
	}

	动作
	{
		事件玩家.tracer_curr_hit = 生命值(被攻击方) * 0.050;
		伤害(被攻击方, 攻击方, 事件玩家.tracer_curr_hit);
		If((具有状态(被攻击方, 沉睡) || 具有状态(被攻击方, 冰冻) || 具有状态(被攻击方, 击倒) || 具有状态(被攻击方, 击晕) || 具有状态(被攻击方, 被入侵)) == 真);
			中止;
		End;
		事件玩家.tracer_hit += 事件玩家.tracer_curr_hit;
	}
}

规则("猎空-换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家.tracer_energy + 事件玩家.tracer_hit > 0;
	}

	动作
	{
		事件玩家.tracer_energy = 999;
		事件玩家.tracer_hit = 999;
	}
}

规则("猎空-重生")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		在重生室中(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
	}
}

规则("源氏-标记")
{
	事件
	{
		玩家造成伤害;
		双方;
		源氏;
	}

	条件
	{
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(辅助攻击模式) || 事件技能 == 按钮(近身攻击) || 事件技能 == 按钮(终极技能)) == 真;
	}

	动作
	{
		被攻击方.genji_flag = 较小(6, 被攻击方.genji_flag + (事件技能 == 按钮(终极技能) ? 6 : 2));
	}
}

规则("源氏-S")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(源氏);
		事件技能 == 按钮(技能1);
	}

	动作
	{
		被攻击方.genji_flag = 取整(被攻击方.genji_flag / 2, 上);
		设置状态(被攻击方, 攻击方, 燃烧, 1.000);
		开始持续伤害(被攻击方, 攻击方, 1.000, (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.100 * 被攻击方.genji_flag);
		为玩家添加生命池(攻击方, 生命值, 10 * (被攻击方.genji_flag - 1), 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(源氏));
		被攻击方.genji_flag = 0;
	}
}

规则("源氏-增伤")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 100, 假, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 12, 英雄(源氏), 自定义字符串("Genji Dragonblade hp pool"));
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家, 150, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 7, 英雄(源氏), 自定义字符串("Genji Dragonblade adjust"));
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 50, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 7, 英雄(源氏), 自定义字符串("Genji Dragonblade adjust"));
		等待直到 (正在使用终极技能(事件玩家) != 真, 10);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Genji Dragonblade adjust") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
		等待(5, 无视条件);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Genji Dragonblade hp pool") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("源氏-E-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 50, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(源氏));
	}
}

规则("破坏球-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		破坏球;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.wrecking_ball_players = 范围内玩家(事件玩家, 8, 所在队伍(事件玩家), 表面及敌方屏障);
		开始伤害调整(事件玩家.wrecking_ball_players, 所有玩家(所在队伍(事件玩家)), 60, 无);
		事件玩家.wrecking_ball_dec_id = 上一个伤害调整ID;
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 事件玩家;
		等待(5, 无视条件);
		停止伤害调整(事件玩家.wrecking_ball_dec_id);
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 0;
	}
}

规则("破坏球-减伤")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件玩家.wrecking_ball_dec != 0;
		攻击方 != 空;
	}

	动作
	{
		伤害(事件玩家.wrecking_ball_dec, 攻击方, 事件伤害 * 0.500);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(白色), 事件玩家, 1);
	}
}

规则("布丽吉塔-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.buligita_players = 范围内玩家(眼睛位置(事件玩家), 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
		设置状态(事件玩家.buligita_players, 事件玩家, 无敌, 0.300);

		开始伤害调整(事件玩家.buligita_players, 所有玩家(所有队伍), 85, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 11, 英雄(布丽吉塔), 自定义字符串("Brigitte Rally"));

		创建效果(所有玩家(所有队伍), 火花, 颜色(黄色), 事件玩家, 8, 位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 11, 英雄(布丽吉塔), 自定义字符串("Brigitte Rally"));

		While(正在使用终极技能(事件玩家) == 真);
			事件玩家.buligita_players = 范围内玩家(眼睛位置(事件玩家), 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
			事件玩家.buligita_players.i_sys_speed += 20;
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家.buligita_players, 20), 总计消耗时间, 0.20, 英雄(布丽吉塔), 自定义字符串("Brigitte Rally"));
			等待直到(正在使用终极技能(事件玩家) != 真, 0.20);
		End;

		设置移动速度(事件玩家.buligita_players, 100);

		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Rally") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
		事件玩家.buligita_players = 空;
	}
}

规则("奥丽莎-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		奥丽莎;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		施加推力(范围内玩家(事件玩家, 9, 对方队伍(所在队伍(事件玩家)), 表面及敌方屏障), 矢量(0, 1, 0), 8, 至地图, 取消相反运动);

		事件玩家.orisa_teammates = 从数组中移除(范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);

		开始伤害调整(事件玩家.orisa_teammates, 所有玩家(对方队伍(所在队伍(事件玩家))), 60, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 6, 英雄(奥丽莎), 自定义字符串("Orisa Terra Surge"));

		While(正在使用终极技能(事件玩家) == 真);
			事件玩家.orisa_teammates.orisa_master = 空;
			事件玩家.orisa_teammates = 从数组中移除(范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
			事件玩家.orisa_teammates.orisa_master = 事件玩家;
			等待直到 (正在使用终极技能(事件玩家) != 真, 1);
		End;

		事件玩家.orisa_teammates.orisa_master = 空;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Orisa Terra Surge") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
		事件玩家.orisa_teammates = 空;
	}
}

规则("奥丽莎-Q-吸收伤害")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件玩家.orisa_master != 空;
		正在使用终极技能(事件玩家.orisa_master) == 真;
		所在队伍(被攻击方) != 所在队伍(攻击方);
	}

	动作
	{
		伤害(事件玩家.orisa_master, 攻击方, 事件伤害 * 0.666);
		播放效果(从数组中移除(所有玩家(所有队伍), 事件玩家.orisa_master), 有害爆炸, 颜色(灰绿色), 事件玩家.orisa_master, 1);
	}
}

规则("卢西奥-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置引力(事件玩家, 500);
		等待直到 (正在使用终极技能(事件玩家) != 真, 1);
		设置引力(事件玩家, 100);
		If(正在使用终极技能(事件玩家) == 真 && 存活(事件玩家) == 真);
			范围内玩家(事件玩家, 30, 所在队伍(事件玩家), 表面及敌方屏障).lucio_debuff_clear = 真;
		Else;
	}
}

规则("卢西奥-Q-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
	}

	动作
	{
		等待(6, 无视条件);
		事件玩家.lucio_debuff_clear = 假;
	}
}

规则("卢西奥-Q-负面状态清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
		(具有状态(事件玩家, 冰冻) || 具有状态(事件玩家, 击倒) || 具有状态(事件玩家, 击晕) || 具有状态(事件玩家, 沉睡) || 具有状态(事件玩家, 燃烧) || 具有状态(事件玩家, 被入侵)) == 真;
	}

	动作
	{
		清除状态(事件玩家, 冰冻);
		清除状态(事件玩家, 沉睡);
		清除状态(事件玩家, 燃烧);
		清除状态(事件玩家, 击倒);
		清除状态(事件玩家, 击晕);
		清除状态(事件玩家, 被入侵);
		等待(0.100, 无视条件);
		清除状态(事件玩家, 冰冻);
		清除状态(事件玩家, 沉睡);
		清除状态(事件玩家, 燃烧);
		清除状态(事件玩家, 击倒);
		清除状态(事件玩家, 击晕);
		清除状态(事件玩家, 被入侵);
	}
}

规则("卢西奥-被动-滑墙")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		在墙上(事件玩家) == 真;
		在地面上(事件玩家) != 真;
	}

	动作
	{
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 90, 受伤害者和伤害者);
		事件玩家.lucio_slice_dec = 上一个伤害调整ID;
	}
}

规则("卢西奥-被动-冷静光环")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		While(存活(事件玩家));
			事件玩家.lucio_players = 范围内玩家(眼睛位置(事件玩家), 12, 所在队伍(事件玩家), 表面及敌方屏障);
			事件玩家.lucio_players.d_sys_cd += 0.1;
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_move_cd, 数组(事件玩家.lucio_players, 0.1), 总计消耗时间, 0.20, 英雄(卢西奥), 自定义字符串("Lucio Crossfade"));
			等待(0.2, 无视条件);
		End;
	}
}

规则("卢西奥-被动-滑墙-解除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_slice_dec != 空;
		(所用英雄(事件玩家) != 英雄(卢西奥) || 在墙上(事件玩家) != 真 || 在地面上(事件玩家)) == 真;
	}

	动作
	{
		停止伤害调整(事件玩家.lucio_slice_dec);
		事件玩家.lucio_slice_dec = 0;
	}
}

规则("卢西奥-E-强化强音")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		数量(事件玩家.lucio_players) > 0;
	}

	动作
	{
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家.lucio_players, 115, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 3, 英雄(卢西奥), 自定义字符串("Lucio Amp It Up"));
	}
}

规则("黑影-伤害")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(黑影);
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(主要攻击模式)) == 真;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		If(事件玩家.sombra_player == 空);
			事件玩家.sombra_player = 攻击方;
			事件玩家.sombra_demage = 事件伤害;
			事件玩家.sombra_timer = 3;
		Else If(事件玩家.sombra_player == 攻击方);
			事件玩家.sombra_demage += 事件伤害;
			事件玩家.sombra_timer = 3;
		Else;
			中止;
		End;
		If(事件玩家.sombra_demage > 最大生命值(事件玩家) * 0.500);
			设置状态(事件玩家, 事件玩家.sombra_player, 被入侵, 3);
			事件玩家.sombra_hacked = 真;
			事件玩家.sombra_timer = 0;
			事件玩家.sombra_player = 空;
			事件玩家.sombra_demage = 0;
			等待(8, 无视条件);
			事件玩家.sombra_hacked = 假;
		End;
	}
}

规则("黑影-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sombra_player != 空;
		事件玩家.sombra_demage > 0;
		事件玩家.sombra_timer > 0;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		While(事件玩家.sombra_timer > 0);
			等待直到 (事件玩家.sombra_timer <= 0, 1);
			事件玩家.sombra_timer -= 1;
		End;
		事件玩家.sombra_player = 空;
		事件玩家.sombra_demage = 0;
	}
}

规则("布丽吉塔-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用辅助武器(事件玩家) != 真, 1.500);
		创建效果(所有玩家(所有队伍), 环, 自定义颜色(248, 213, 97, 171), 事件玩家, 10, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, -1, 英雄(布丽吉塔), 自定义字符串("Brigitte Barrier Shield"));
		While(正在使用辅助武器(事件玩家) == 真);
			开始持续治疗(范围内玩家(事件玩家, 10, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家, 0.500, 10);
			等待直到 (正在使用辅助武器(事件玩家) != 真, 0.500);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Barrier Shield") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("布丽吉塔-基础生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 护甲, 50, 真, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(布丽吉塔));
	}
}

规则("死神-被动-暗影")
{
	事件
	{
		玩家受到伤害;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) != 真;
		全局.random <= 0.100;
		事件玩家.ana_healing_preventing <= 0;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家, 相移, 0.500);
		等待(0.500, 无视条件);
	}
}

规则("死神-主武器-坦克杀手")
{
	事件
	{
		玩家造成伤害;
		双方;
		死神;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		数组包含(所有重装英雄, 所用英雄(被攻击方)) == 真;
	}

	动作
	{
		If(类型的生命值(被攻击方, 护甲) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.300);
		Else If(类型的生命值(被攻击方, 护盾) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.200);
		Else;
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.100);
		End;
	}
}

规则("死神-S-暗影")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待(0.410, 无视条件);
		设置状态(事件玩家, 事件玩家, 相移, 2);
		开始按下按钮(事件玩家, 按钮(技能1));
		等待直到 (正在使用技能 1(事件玩家) != 真, 3);
		停止按下按钮(事件玩家, 按钮(技能1));
		禁用按钮(事件玩家, 按钮(终极技能));
	}
}

规则("死神-暗影-特效")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) == 真;
		事件玩家.reaper_shadow == 空;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 云, 颜色(紫色), 事件玩家, 1.500, 可见，位置和半径);
		事件玩家.reaper_shadow = 最后创建的实体;
	}
}

规则("死神-暗影-特效-消除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(英雄(死神) != 所用英雄(事件玩家) || 具有状态(事件玩家, 相移) != 真) == 真;
		事件玩家.reaper_shadow != 空;
	}

	动作
	{
		可用按钮(事件玩家, 按钮(终极技能));
		消除效果(事件玩家.reaper_shadow);
		事件玩家.reaper_shadow = 空;
	}
}

规则("DVA-被暴击")
{
	事件
	{
		玩家受到伤害;
		双方;
		D.Va;
	}

	条件
	{
		(事件暴击 || 事件技能 == 空) == 真;
		处于非初始状态(事件玩家) != 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 较大(事件伤害 * 0.500, 10) * (事件暴击 ? 1.0 : 0.3), 假, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.5, 英雄(D.Va));
	}
}

规则("DVA-被动-飞行矩阵回复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		While(正在使用技能 1(事件玩家) == 真);
			设置技能资源(事件玩家, 按钮(辅助攻击模式), 2 + 技能资源(事件玩家, 按钮(辅助攻击模式)));
			等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		End;
	}
}

规则("DVA-被动-护甲回复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		事件玩家.dva_armor_recover == 空;
		类型的生命值(事件玩家, 护甲) > 0.00;
		处于非初始状态(事件玩家) != 真;
	}

	动作
	{
		开始持续治疗(事件玩家, 事件玩家, 9999999, 10);
		事件玩家.dva_armor_recover = 上一个持续治疗效果ID;
	}
}

规则("DVA-被动-护甲回复-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.dva_armor_recover != 空;
		(英雄(D.Va) != 所用英雄(事件玩家) || 处于非初始状态(事件玩家) || 类型的生命值(事件玩家, 护甲) <= 0.00) == 真;
	}

	动作
	{
		停止持续治疗(事件玩家.dva_armor_recover);
		事件玩家.dva_armor_recover = 空;
	}
}

规则("巴蒂斯特-S-临时生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, (最大生命值(事件玩家) - 生命值(事件玩家)) * 0.400, 假, 假);
		事件玩家.baptiste_shift_hp = 最后创建的生命池;
		事件玩家.sys_data_record[1] += (最大生命值(事件玩家) - 生命值(事件玩家)) * 0.400;
		等待(3, 无视条件);
		移除玩家的生命池(事件玩家.baptiste_shift_hp);
	}
}

规则("巴蒂斯特-主武器-附加伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		巴蒂斯特;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		伤害(被攻击方, 攻击方, 生命值(被攻击方) * 0.040);
	}
}

规则("巴蒂斯特-副武器-弹匣大小")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	动作
	{
		设置最大弹药(事件玩家, 1, 14);
		设置弹药(事件玩家, 1, 最大弹药量(事件玩家, 1));
	}
}

规则("巴蒂斯特-副武器-双发扳机")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待(0.065, 无视条件);
		If(弹药(事件玩家, 1) > 0);
			创建弹道(巴蒂斯特生化榴弹枪, 事件玩家, 眼睛位置(事件玩家), 面朝方向(事件玩家), 至地图, 治疗, 所在队伍(事件玩家), 50, 1.000, 3, 有益爆炸, 巴蒂斯特生化榴弹枪爆炸声音, 0, 60, 6, 0, 0, 20);
			等待直到(正在使用辅助武器(事件玩家) != 真, 0.500);
			等待(0.05, 无视条件);
			设置弹药(事件玩家, 1, 弹药(事件玩家, 1) - 1);
		End;
	}
}

规则("西格玛-Q-炮塔放置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		等待(0.500, 无视条件);
		If(存活(事件玩家) && 正在使用终极技能(事件玩家) != 真 && 具有状态(事件玩家, 被入侵) != 真);
			中止;
		End;
		事件玩家.sigma_battery_pos = 眼睛位置(事件玩家);
		创建效果(所有玩家(所在队伍(事件玩家)), 球, 颜色(蓝色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 数组(最后创建的实体);
		创建效果(所有玩家(对方队伍(所在队伍(事件玩家))), 球, 颜色(红色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 添加至数组(事件玩家.sigma_battery_pic, 最后创建的实体);
		等待(8, 无视条件);
		事件玩家.sigma_battery_pos = 空;
		消除效果(事件玩家.sigma_battery_pic[0]);
		消除效果(事件玩家.sigma_battery_pic[1]);
		事件玩家.sigma_battery_pic = 空;
	}
}

规则("西格玛-Q-炮塔攻击")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		事件玩家.sigma_battery_pos != 空;
	}

	动作
	{
		While(事件玩家.sigma_battery_pos != 空);
			事件玩家.sigma_battery_target = 已排序的数组(范围内玩家(事件玩家.sigma_battery_pos, 15, 对方队伍(所在队伍(事件玩家)), 表面), (存活(当前数组元素) && !具有状态(事件玩家, 无敌) && !具有状态(事件玩家, 相移)) ? 标准化生命值(当前数组元素) - (
				正在空中(当前数组元素) && !正在跳跃(当前数组元素) ? (标准化生命值(当前数组元素) >= 0.500 ? 1 : -1) : 0) : 9999)[0];
			If(事件玩家.sigma_battery_target != 空 && 存活(事件玩家.sigma_battery_target));
				If(正在空中(事件玩家.sigma_battery_target) && !正在跳跃(事件玩家.sigma_battery_target));
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						60, 0.300, 3, 有害爆炸, 爆炸声音, 0, 96, 0.156, 1.100, 0, 0);
					等待(0.335, 无视条件);
				Else;
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						30, 0.300, 3, 有害爆炸, 爆炸声音, 0, 48, 0.312, 1.100, 0, 0);
					等待(0.670, 无视条件);
				End;
			Else;
				等待(0.050, 无视条件);
			End;
		End;
		事件玩家.sigma_battery_target = 空;
	}
}

规则("安娜-被动-治疗护盾")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(安娜);
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 20, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 0.5, 空);
	}
}

规则("安娜-E-禁疗强化")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(安娜);
		事件技能 == 按钮(技能2);
	}

	动作
	{
		事件玩家.ana_healing_preventing = 2;
		等待(3, 无视条件);
		事件玩家.ana_healing_preventing = 1;
		等待(2, 无视条件);
		事件玩家.ana_healing_preventing = 0;
	}
}

规则("安娜-E-禁疗状态")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ana_healing_preventing == 2;
	}

	动作
	{
		开始治疗调整(事件玩家, 所有玩家(所在队伍(事件玩家)), 50, 受治疗者，治疗者及治疗百分比);
		事件玩家.ana_healing_preventing_status = 上一个治疗调整ID;
	}
}

规则("安娜-E-禁疗清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ana_healing_preventing == 0;
	}

	动作
	{
		停止治疗调整(事件玩家.ana_healing_preventing_status);
	}
}

规则("卡西迪-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		卡西迪;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 事件伤害 * 0.250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(卡西迪));
	}
}

规则("末日铁拳-被动-无损蓄力-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串("Doomfist Rocket Punch"));
		等待直到 (按钮被按下(事件玩家, 按钮(辅助攻击模式)) != 真 || 正在使用辅助武器(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Rocket Punch") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("末日铁拳-被动-无损蓄力-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串("Doomfist Power Block"));
		等待直到 (正在使用技能 2(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Power Block") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("末日铁拳-被动-无损蓄力-S")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串("Doomfist Seismic Slam"));
		等待直到 (正在使用技能 1(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Seismic Slam") ? 数组分割(当前数组元素, 0, 2) : 当前数组元素);
	}
}

规则("艾什-主武器-霰弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		If(!正在使用辅助武器(事件玩家));
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
		Else;
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * ((正在跳跃(事件玩家) || 正在空中(事件玩家)) ? 1.5 : (正在蹲下(事件玩家) ? 0.8 : 1.0)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
		End;
	}
}

规则("禅雅塔-被动-宁")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	动作
	{
		等待(5.00, 无视条件);
		为玩家添加生命池(所有玩家(所在队伍(事件玩家)), 护甲, 25, 真, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(禅雅塔));
	}
}

规则("禅雅塔-被动-破")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	条件
	{
		弹药(事件玩家, 0) % 5 == 0;
		弹药(事件玩家, 0) != 最大弹药量(事件玩家, 0);
	}

	动作
	{
		等待直到(!正在使用辅助武器(事件玩家), 99999);
		If(!存活(事件玩家.zenyata_target) || !在视野内(事件玩家, 事件玩家.zenyata_target, 90));
			事件玩家.zenyata_target = 距离准星最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)));
		End;
		If(!存活(事件玩家.zenyata_target) || !在视野内(事件玩家, 事件玩家.zenyata_target, 90));
			事件玩家.zenyata_target = 空;
		End;
		// 创建追踪弹道(西格玛超能之球, 事件玩家, 空, (事件玩家.zenyata_target == 空 ? 空 : 方向(眼睛位置(事件玩家), 眼睛位置(事件玩家.zenyata_target))), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 48, 2.0, 0, 有益爆炸, 爆炸声音, 0, 90, 5, 0, 事件玩家.zenyata_target, 1.0);
		创建追踪弹道(“秩序之光”光子发射器, 事件玩家, 空, 空, 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 48, 2.0, 0, 有益爆炸, 爆炸声音, 0, 90, 5, 0, 事件玩家.zenyata_target, 1.0);
	}
}

规则("禅雅塔-被动-破-索敌")
{
	事件
	{
		玩家造成伤害;
		双方;
		禅雅塔;
	}

	条件
	{
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		攻击方.zenyata_target = 被攻击方;
	}
}

规则("索杰恩-主武器-弹速增强")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真);
			设置弹道速度(事件玩家, 100000);
			等待直到 (正在使用主要武器(事件玩家) != 真, 1.5);
			中断;
		End;
		设置弹道速度(事件玩家, 100);
	}
}

规则("索杰恩-Q-伤害累积")
{
	事件
	{
		玩家造成伤害;
		双方;
		索杰恩;
	}

	条件
	{
		((事件技能 == 按钮(终极技能) && 正在使用终极技能(攻击方)) || (事件玩家.sojourn_Q_demage_count > 0 && 事件技能 == 按钮(辅助攻击模式))) == 真;
	}

	动作
	{
		伤害(被攻击方, 攻击方, 事件暴击 ? 攻击方.sojourn_Q_demage_count * 2 : 攻击方.sojourn_Q_demage_count);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(红色), 被攻击方, 1);
		If(正在使用终极技能(攻击方));
			攻击方.sojourn_Q_demage_count += (攻击方.sojourn_Q_demage_count > 120 ? 10 : 20);
		Else;
			攻击方.sojourn_Q_demage_count = 0;
		End;
	}
}

规则("索杰恩-Q-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sojourn_Q_demage_count = 0;
	}
}

规则("索杰恩-主武器-弹药")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		最大弹药量(事件玩家, 0) < 450;
	}

	动作
	{
		设置最大弹药(事件玩家, 0, 450);
		设置弹药(事件玩家, 0, 450);
	}
}

规则("索杰恩-主武器-命中")
{
	事件
	{
		玩家造成伤害;
		双方;
		索杰恩;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		事件玩家.sojourn_bullet_count += 1;
	}
}

规则("索杰恩-主武器-弹药")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		弹药(事件玩家, 0) == 450;
	}

	动作
	{
		事件玩家.sojourn_bullet_count = 0;
	}
}

规则("索杰恩-主武器-换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		事件玩家.sojourn_bullet_count >= 45;
		弹药(事件玩家, 0) != 450;
	}

	动作
	{
		While(弹药(事件玩家, 0) != 450 || 事件玩家.sojourn_bullet_count >= 45);
			设置弹药(事件玩家, 0, 0);
			等待(1.25, 当为“假”时中止);
		End;
	}
}

规则("索杰恩-文本显示")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("弹药：{0}", 45 - 事件玩家.sojourn_bullet_count), 自定义字符串("附加伤害：{0}", 事件玩家.sojourn_Q_demage_count), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("温斯顿-副武器-蓄力")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		While((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) == 真);
			等待直到((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) != 真, 0.3);
			事件玩家.winston_power += 2;
		End;
		等待(0.5,无视条件);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-副武器-击退")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		英雄(温斯顿) == 所用英雄(攻击方);
		事件技能 == 按钮(辅助攻击模式);
		攻击方.winston_power > 0;
	}

	动作
	{
		施加推力(被攻击方, 矢量(X方向分量(方向(攻击方, 被攻击方)), 0.25, Z方向分量(方向(攻击方, 被攻击方))), 攻击方.winston_power < 10 ? 攻击方.winston_power * 2 : 攻击方.winston_power + 10, 至地图, 合并相反运动);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-被动-伤害调整")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	条件
	{
		事件玩家.winston_inc == 空;
	}

	动作
	{
		事件玩家.winston_inc = 数组();
		开始伤害调整(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[0] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[1] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[2] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[3] = 上一个伤害调整ID;
		开始伤害调整(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500.0, 100), 受伤害者，伤害者及伤害百分比);
		事件玩家.winston_inc[4] = 上一个伤害调整ID;
	}
}

规则("温斯顿-被动-伤害清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.winston_inc != 空;
		所用英雄(事件玩家) != 英雄(温斯顿);
	}

	动作
	{
		停止伤害调整(事件玩家.winston_inc[0]);
		停止伤害调整(事件玩家.winston_inc[1]);
		停止伤害调整(事件玩家.winston_inc[2]);
		停止伤害调整(事件玩家.winston_inc[3]);
		停止伤害调整(事件玩家.winston_inc[4]);
		事件玩家.winston_inc = 空;
	}
}

规则("查莉娅-被动-重力堡垒-HP记录")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	动作
	{
		While(真);
			事件玩家.zarya_hp_record_tmp = 添加至数组(事件玩家.zarya_hp_record, 生命值(事件玩家));
			If(数量(事件玩家.zarya_hp_record_tmp) > 10);
				事件玩家.zarya_hp_record = 数组分割(事件玩家.zarya_hp_record_tmp, 数量(事件玩家.zarya_hp_record_tmp) - 10, 10);
			Else;
				事件玩家.zarya_hp_record = 事件玩家.zarya_hp_record_tmp;
			End;
			等待(0.100, 无视条件);
		End;
	}
}

规则("查莉娅-文本栏")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("免伤：{0} - 治疗增幅：{1}", (100 - 较小(较大(首个(事件玩家.zarya_hp_record) - 最后(事件玩家.zarya_hp_record), 0) / 5.00, 40.00)), (120 - 较小(较大(最后(事件玩家.zarya_hp_record) - 首个(事件玩家.zarya_hp_record), 0) / 10.00, 20.00))), 自定义字符串(""), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("查莉娅-被动-重力堡垒-调整")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		(事件玩家.zarya_weaken == 空 || 事件玩家.zarya_heal_inc == 空) == 真;
	}

	动作
	{
		If(事件玩家.zarya_weaken == 空);
			开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 100 - 较小(较大(首个(事件玩家.zarya_hp_record) - 最后(事件玩家.zarya_hp_record), 0) / 5.00, 40.00), 受伤害者，伤害者及伤害百分比);
			事件玩家.zarya_weaken = 上一个伤害调整ID;
		End;

		If(事件玩家.zarya_heal_inc == 空);
			开始治疗调整(事件玩家, 所有玩家(所在队伍(事件玩家)), 120 - 较小(较大(最后(事件玩家.zarya_hp_record) - 首个(事件玩家.zarya_hp_record), 0) / 10.00, 20.00), 受治疗者，治疗者及治疗百分比);
			事件玩家.zarya_heal_inc = 上一个治疗调整ID;
		End;
	}
}

规则("查莉娅-被动-重力堡垒-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		英雄(查莉娅) != 所用英雄(事件玩家);
		(事件玩家.zarya_weaken != 空 || 事件玩家.zarya_heal_inc != 空) == 真;
	}

	动作
	{
		If(事件玩家.zarya_weaken != 空);
			停止伤害调整(事件玩家.zarya_weaken);
			事件玩家.zarya_weaken = 空;
		End;
		If(事件玩家.zarya_heal_inc != 空);
			停止治疗调整(事件玩家.zarya_heal_inc);
			事件玩家.zarya_heal_inc = 空;
		End;
	}
}

规则("查莉娅-主武器-爆头")
{
	事件
	{
		玩家造成伤害;
		双方;
		查莉娅;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 15, 被攻击方, 事件玩家, 真), 眼睛位置(被攻击方)) < 0.3;
	}

	动作
	{
		播放效果(事件玩家, 有害选择效果, 颜色(红色), 眼睛位置(被攻击方), 0.5);
		伤害(被攻击方, 事件玩家, 事件伤害 * 0.5);
	}
}

规则("查莉娅-被动-弹药恢复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		(正在使用技能 1(事件玩家) || 正在使用技能 2(事件玩家)) == 真;
	}

	动作
	{
		设置弹药(事件玩家, 0, 较小(最大弹药量(事件玩家, 0), 弹药(事件玩家, 0) + 25));
	}
}

规则("秩序之光-Q-大招增幅")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		秩序之光;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		创建效果(事件玩家, 火花, 颜色(天蓝色), 事件玩家, 15, 可见，位置和半径);
		事件玩家.symmetra_Q_effect = 最后创建的实体;

		While((正在使用终极技能(事件玩家) && 存活(事件玩家)) == 真);
			事件玩家.symmetra_Q_players = 从数组中移除(范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
			For 玩家变量(事件玩家, symmetra_Q_inedx, 0, 数量(事件玩家.symmetra_Q_players), 1);
				设置终极技能充能(事件玩家.symmetra_Q_players[事件玩家.symmetra_Q_inedx], 终极技能充能百分比(事件玩家.symmetra_Q_players[事件玩家.symmetra_Q_inedx]) + 1);
				等待直到((正在使用终极技能(事件玩家) && 存活(事件玩家)) != 真, 0.00);
			End;
			事件玩家.symmetra_Q_inedx = 0;
			等待直到((正在使用终极技能(事件玩家) && 存活(事件玩家)) != 真, 0.43);
		End;

		消除效果(事件玩家.symmetra_Q_effect);
		事件玩家.symmetra_Q_effect = 空;
	}
}

规则("秩序之光-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		秩序之光;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 事件伤害 * 0.3, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 6, 英雄(秩序之光));
	}
}

规则("渣客女王-被动-标记")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(渣客女王);
		(事件技能 == 按钮(技能2) || 事件技能 == 按钮(辅助攻击模式) || 事件技能 == 按钮(近身攻击) || 事件技能 == 按钮(终极技能)) == 真;
	}

	动作
	{
		被攻击方.junkerqueen_timer = 0.4;

		If(被攻击方.junkerqueen_effect != 空 && 攻击方 != 被攻击方.junkerqueen_effect[0]);
			停止伤害调整(事件玩家.junkerqueen_effect[1]);
			停止治疗调整(事件玩家.junkerqueen_effect[2]);
			事件玩家.junkerqueen_effect = 空;
		End;

		If(被攻击方.junkerqueen_effect == 空);
			被攻击方.junkerqueen_effect = 数组(攻击方);
			开始伤害调整(所有玩家(所在队伍(攻击方)), 被攻击方, 85, 受伤害者和伤害者);
			被攻击方.junkerqueen_effect = 添加至数组(被攻击方.junkerqueen_effect, 上一个伤害调整ID);
			开始治疗调整(被攻击方, 所有玩家(所有队伍), 85, 受治疗者和治疗者);
			被攻击方.junkerqueen_effect = 添加至数组(被攻击方.junkerqueen_effect, 上一个治疗调整ID);
		End;
	}
}

规则("渣客女王-被动-标记-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.junkerqueen_timer <= 0;
		事件玩家.junkerqueen_effect != 空;
	}

	动作
	{
		停止伤害调整(事件玩家.junkerqueen_effect[1]);
		停止治疗调整(事件玩家.junkerqueen_effect[2]);
		事件玩家.junkerqueen_effect = 空;
	}
}

规则("渣客女王-shift-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sys_players_record[0] = 0;
		事件玩家.sys_players_record[1] = 空;
		事件玩家.sys_players_record[2] = 范围内玩家(眼睛位置(事件玩家), 15, 所在队伍(事件玩家), 表面及敌方屏障);

		While(事件玩家.sys_players_record[0] < 数量(事件玩家.sys_players_record[2]));
			事件玩家.sys_players_record[1] = 数组中的值(事件玩家.sys_players_record[2], 事件玩家.sys_players_record[0]);
			If(事件玩家.sys_players_record[1] == 事件玩家);
				事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns)] = 数组(0.30, 总计消耗时间, 5, 英雄(渣客女王), 自定义字符串("Junker Queen Commanding Shout"), 事件玩家);
			Else;
				事件玩家.sys_players_record[1].sys_status_thorns[数量(事件玩家.sys_players_record[1].sys_status_thorns)] = 数组(0.25, 总计消耗时间, 3, 空, 自定义字符串("Junker Queen Commanding Shout"), 事件玩家);
			End;
			事件玩家.sys_players_record[0] += 1;
		End;

		事件玩家.sys_players_record = 空;
	}
}

规则("渣客女王-E-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns)] = 数组(0.85, 总计消耗时间, 5, 英雄(渣客女王), 自定义字符串("Junker Queen Carnage"), 事件玩家);
		等待直到(!正在使用技能 2(事件玩家), 5.0);
		事件玩家.sys_status_thorns = 已过滤的数组(事件玩家.sys_status_thorns, 当前数组元素[4] != 自定义字符串("Junker Queen Carnage"));
	}
}

规则("渣客女王-终极技能-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns)] = 数组(0.20, 总计消耗时间, 6, 英雄(渣客女王), 自定义字符串("Junker Queen Rampage"), 事件玩家);
		等待直到(!正在使用终极技能(事件玩家), 6.0);
		事件玩家.sys_status_thorns = 已过滤的数组(事件玩家.sys_status_thorns, 当前数组元素[4] != 自定义字符串("Junker Queen Rampage"));
	}
}

规则("渣客女王-初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("荆棘造成伤害：{0}", 事件玩家.sys_data_record[1]), 自定义字符串(""), 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("黑百合-副武器-开镜-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		黑百合;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.widowmaker_hp_pool == 空;
		事件玩家.widowmaker_hp_pool_timer <= 0;
	}

	动作
	{
		等待(0.2, 当为“假”时中止);
		为玩家添加生命池(事件玩家, 生命值, 300, 假, 假);
		事件玩家.widowmaker_hp_pool = 最后创建的生命池;
	}
}

规则("黑百合-副武器-开镜-护盾破碎")
{
	事件
	{
		玩家受到伤害;
		双方;
		黑百合;
	}

	条件
	{
		事件玩家.widowmaker_hp_pool != 空;
	}

	动作
	{
		等待(0.3, 当为“假”时中止);
		播放效果(攻击方, “末日铁拳”上勾重拳击中声音, 颜色(白色), 攻击方, 9999);
		播放效果(被攻击方, “末日铁拳”上勾重拳击中声音, 颜色(白色), 被攻击方, 9999);
		事件玩家.widowmaker_hp_pool_timer = 正在使用终极技能(事件玩家) ? 2.00 : 6.00;
	}
}

规则("黑百合-副武器-开镜-护盾清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.widowmaker_hp_pool != 空;
		(所用英雄(事件玩家) != 英雄(黑百合) || 正在使用辅助武器(事件玩家) != 真 || 事件玩家.widowmaker_hp_pool_timer > 0) == 真;
	}

	动作
	{
		移除玩家的生命池(事件玩家.widowmaker_hp_pool);
		事件玩家.widowmaker_hp_pool = 空;
	}
}

规则("黑百合-Q-弹匣拓展")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		黑百合;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置最大弹药(事件玩家, 0, 70);
		设置弹药(事件玩家, 0, 弹药(事件玩家, 0) + 35);

		等待直到(正在使用终极技能(事件玩家) != 真, 20);
		设置最大弹药(事件玩家, 0, 35);
	}
}

规则("黑百合-Q-伤害增幅")
{
	事件
	{
		玩家造成伤害;
		双方;
		黑百合;
	}

	条件
	{
		正在使用终极技能(攻击方) == 真;
		正在使用辅助武器(攻击方) == 真;
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		伤害(被攻击方, 攻击方, 事件伤害);
	}
}

规则("堡垒-坦克炮弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		堡垒;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		While(正在使用技能 1(事件玩家) && 正在使用主要武器(事件玩家));
			If(全局.random < 水平速度(事件玩家) * 0.16);
				创建弹道(“法老之鹰”火箭, 事件玩家, 眼睛位置(事件玩家), 面朝方向(事件玩家), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 30 + 最大生命值(事件玩家) * 0.1, 0.5, 3.0, 有害爆炸, 爆炸声音, 0, 80, 3.0, 0, 0, 0);
			End;
			等待(0.500, 无视条件);
		End;
	}
}

规则("路霸-被动-单打独斗")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		路霸;
	}

	动作
	{
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家, 100 + 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8.0, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串("Roadhog Alone"));

		开始伤害调整(事件玩家, 所有玩家(所有队伍), 100 - 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8.0, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串("Roadhog Alone"));

		开始治疗调整(事件玩家, 所有玩家(所有队伍), 100 + 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8.0, 受治疗者，治疗者及治疗百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_heal_adjust, 上一个治疗调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串("Roadhog Alone"));
	}
}

规则("路霸-被动-单打独斗-移除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.roadhog_mates_flag == 真;
	}

	动作
	{
		等待(5.00, 当为“假”时中止);
		事件玩家.roadhog_mates_flag = 假;
	}
}

规则("路霸-被动-单打独斗-队友阵亡")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	动作
	{
		事件玩家.roadhog_mates_flag = 真;
	}
}

禁用 规则("debug-hp")
{
	事件
	{
		
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		创建地图文本(所有玩家(所有队伍), 自定义字符串("{0} / {1}", 生命值(事件玩家), 最大生命值(事件玩家)), 事件玩家, 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色), 默认可见度);
	}
}

规则("debug")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		设置终极技能充能(事件玩家, 100);

		If(事件玩家.debug_robot == 空);
			创建HUD文本(事件玩家, 自定义字符串("{0} - {1}", 事件玩家.debug_2, 水平速度(事件玩家)), 自定义字符串("shift：{0} E：{1} Q：{2}", 正在使用技能 1(事件玩家), 正在使用技能 2(事件玩家), 正在使用终极技能(事件玩家)), 自定义字符串("主武器：{0} 副武器：{1}", 正在使用主要武器(事件玩家), 正在使用辅助武器(事件玩家)), 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			生成机器人(英雄(D.Va), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(半藏), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(卢西奥), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(奥丽莎), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			事件玩家.debug_robot = 最后创建的实体;
		Else;
			传送(所有玩家(所有队伍), 事件玩家);
		End;
		// 设置最大生命值(事件玩家.debug_robot, 9999999);
		等待(1, 无视条件);
		设置终极技能充能(事件玩家.debug_robot, 100);
		// 开始按下按钮(事件玩家.debug_robot, 按钮(辅助攻击模式));
		等待(1, 无视条件);
		// 按下按键(事件玩家.debug_robot, 按钮(终极技能));
		// 设置玩家生命值(事件玩家.debug_robot, 1);
	}
}

规则("debug_hit")
{
	事件
	{
		玩家造成伤害;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		事件玩家.debug_2 = 字符串("{0} - {1}", 事件伤害, 事件技能);
	}
}

规则("debug_heal")
{
	事件
	{
		玩家造成治疗;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		事件玩家.debug_2 = 字符串("{0} - {1}", 事件治疗, 事件技能);
	}
}