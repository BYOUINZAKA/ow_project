设置
{
	模式
	{
		占领要点
		{
			启用地图
			{
			}
		}

		攻击护送
		{
			启用地图
			{
			}
		}

		攻防阵线

		机动推进
		{
			启用地图
			{
			}
		}

		运载目标
		{
			启用地图
			{
			}
		}

		闪点作战
		{
			启用地图
			{
			}
		}
	}

	英雄
	{
		综合
		{
			伊拉锐
			{
				治疗量: 10%
			}

			死神
			{
				幽灵形态冷却时间: 125%
			}

			猎空
			{
				无需装弹: 开启
			}

			艾什
			{
				延时雷管引爆时间: 1%
				战斗时终极技能充能速度 召唤鲍勃: 70%
			}
		}
	}

	扩展
	{
		爆炸声音
		弹道
	}
}

变量
{
	全局:
		0: random
		1: t_enum_hp_pool
		2: t_enum_damage_adjust
		3: t_enum_heal_adjust
		4: t_enum_effect
		5: t_enum_speed
		6: t_enum_move_cd
		7: t_enum_map_text
		20: ci_tracer_max_energy
		21: ci_tracer_max_hit
		23: cd_lucio_cd_dec

	玩家:
		0: d_sys_cd
		1: i_sys_pre_speed
		2: i_sys_speed
		5: tracer_energy
		6: tracer_energy_reset
		7: tracer_energy_last
		8: tracer_hit
		9: tracer_hit_last
		10: reinhardt_shield
		13: genji_flag
		15: mei_Q_timer
		16: mei_Q_pos
		17: mei_Q_dec
		18: reaper_shadow
		20: buligita_players
		21: roadhog_mates_flag
		22: roadhog_hit_flag
		25: ana_healing_preventing
		26: ana_healing_preventing_status
		30: lucio_debuff_clear
		31: lucio_slice_dec
		32: lucio_players
		40: sombra_demage
		41: sombra_timer
		42: sombra_player
		43: sombra_hacked
		45: dva_armor_recover
		50: wrecking_ball_dec
		51: wrecking_ball_players
		52: wrecking_ball_dec_id
		60: orisa_teammates
		63: orisa_master
		65: sigma_battery_pos
		66: sigma_battery_pic
		67: sigma_battery_target
		70: baptiste_shift_hp
		71: zenyata_target
		72: ramattra_absorb
		75: illari_poison
		76: illari_i
		80: winston_power
		85: zarya_hp_record
		86: zarya_hp_record_tmp
		87: zarya_weaken
		88: zarya_heal_inc
		90: sojourn_Q_demage_count
		91: sojourn_bullet_count
		95: symmetra_Q_effect
		96: symmetra_Q_players
		97: symmetra_Q_inedx
		100: debug_robot
		101: debug_1
		102: debug_2
		103: sys_data_record
		105: sys_default_status_pool
		106: sys_players_record
		107: sys_default_status_pool_i
		108: sys_status_thorns
		109: sys_self_text
		110: junkerqueen_effect
		111: junkerqueen_timer
		120: widowmaker_hp_pool
		121: widowmaker_hp_pool_timer
}

子程序
{
	0: remove_default_status
}

规则("常量")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.t_enum_hp_pool = 1;
		全局.t_enum_damage_adjust = 2;
		全局.t_enum_heal_adjust = 3;
		全局.t_enum_effect = 4;
		全局.t_enum_speed = 5;
		全局.t_enum_move_cd = 6;
		全局.t_enum_map_text = 7;
		全局.ci_tracer_max_energy = 100;
		全局.ci_tracer_max_hit = 200;
		全局.cd_lucio_cd_dec = 0.100;
	}
}

规则("随机数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		While(真);
			全局.random = 随机实数(0, 1);
			等待(0, 无视条件);
		End;
	}
}

规则("状态显示文本")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		创建HUD文本(数量(事件玩家.sys_status_thorns) > 0 ? 事件玩家 : 空, 自定义字符串(""), 自定义字符串("荆棘：{0}%", 事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns)
			- 1][0] * 100), 自定义字符串(""), 右边, 0, 颜色(白色), 颜色(绿色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("状态清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sys_status_thorns != 空;
		数量(事件玩家.sys_status_thorns) > 0;
	}

	动作
	{
		While(真);
			等待(0.100, 无视条件);
			If(数量(事件玩家.sys_status_thorns) > 0);
				事件玩家.sys_status_thorns = 已排序的数组(已过滤的数组(事件玩家.sys_status_thorns, 当前数组元素[1] < 0 || 当前数组元素[2] < 0 ? 当前数组元素[3] == 空 || 所用英雄(事件玩家)
					== 当前数组元素[3] : 总计消耗时间 - 当前数组元素[1] <= 当前数组元素[2] && (当前数组元素[3] == 空 || 所用英雄(事件玩家) == 当前数组元素[3])), 当前数组元素[0]);
			End;
		End;
	}
}

规则("玩家状态-荆棘")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		数量(被攻击方.sys_status_thorns) > 0;
		数量(攻击方.sys_status_thorns) <= 0;
	}

	动作
	{
		伤害(攻击方, 被攻击方, 事件伤害 * 被攻击方.sys_status_thorns[数量(被攻击方.sys_status_thorns) - 1][0]);
		If(截取字符串(被攻击方.sys_status_thorns[数量(被攻击方.sys_status_thorns) - 1][4], 0, 字符串长度(自定义字符串("Junker Queen"))) == 自定义字符串("Junker Queen"));
			被攻击方.sys_status_thorns[数量(被攻击方.sys_status_thorns) - 1][5].sys_data_record[1] += 事件伤害 * 被攻击方.sys_status_thorns[数量(
				被攻击方.sys_status_thorns) - 1][0];
		End;
	}
}

规则("回合之间释放资源")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		处于回合之间 == 真;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 数组(当前数组元素[0], 当前数组元素[1]));
	}
}

规则("资源回收执行")
{
	事件
	{
		子程序;
		remove_default_status;
	}

	动作
	{
		If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_hp_pool);
			移除玩家的生命池(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_damage_adjust);
			停止伤害调整(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_heal_adjust);
			停止治疗调整(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_effect);
			消除效果(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_speed);
			事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0].i_sys_speed -= 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1];
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_move_cd);
			事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][0].d_sys_cd -= 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1][1];
		Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][0] == 全局.t_enum_map_text);
			消除地图文本(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][1]);
		End;
		事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i] = 空;
	}
}

规则("系统资源回收")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待直到 (数量(事件玩家.sys_default_status_pool) > 0, 99999);
			等待(0.100, 无视条件);
			For 玩家变量(事件玩家, sys_default_status_pool_i, 数量(事件玩家.sys_default_status_pool) - 1, -1, -1);
				If(数量(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i]) == 2);
					调用子程序(remove_default_status);
				Else If(事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][4] == 空 || 所用英雄(事件玩家)
						== 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][4]);
					If(
						事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][2] >= 0 && 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][3] >= 0 && 总计消耗时间 - 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][2] > 事件玩家.sys_default_status_pool[事件玩家.sys_default_status_pool_i][3]);
						调用子程序(remove_default_status);
					End;
				Else;
					调用子程序(remove_default_status);
				End;
			End;
			事件玩家.sys_default_status_pool = 已过滤的数组(事件玩家.sys_default_status_pool, 当前数组元素 != 空 && 数量(当前数组元素) > 1);
		End;
	}
}

规则("全局定时器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			If(事件玩家.junkerqueen_timer > 0);
				事件玩家.junkerqueen_timer -= 0.100;
			Else;
				事件玩家.junkerqueen_timer = 0;
			End;
			If(事件玩家.widowmaker_hp_pool_timer > 0);
				事件玩家.widowmaker_hp_pool_timer -= 0.100;
			Else;
				事件玩家.widowmaker_hp_pool_timer = 0;
			End;
			If(事件玩家.genji_flag > 0);
				事件玩家.genji_flag = 较大(0, 事件玩家.genji_flag - 0.100);
			End;
			If(事件玩家.reinhardt_shield != 空 && 事件玩家.reinhardt_shield[0] > 0);
				事件玩家.reinhardt_shield[0] -= 0.100;
			End;
			等待(0.100, 无视条件);
		End;
	}
}

规则("个人文本烂")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待(0.500, 无视条件);
			If(事件玩家.sys_self_text != 空 && 所用英雄(事件玩家) != 事件玩家.sys_self_text[0]);
				消除HUD文本(事件玩家.sys_self_text[1]);
				事件玩家.sys_self_text = 空;
			End;
		End;
	}
}

规则("个人数据面板")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.sys_data_record == 空 || 数量(事件玩家.sys_data_record) <= 0 || 所用英雄(事件玩家) != 事件玩家.sys_data_record[0]) == 真;
	}

	动作
	{
		事件玩家.sys_data_record = 数组(所用英雄(事件玩家));
	}
}

规则("sys_speed")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			等待直到 (事件玩家.i_sys_pre_speed != 事件玩家.i_sys_speed, 9999);
			设置移动速度(事件玩家, 100 + 事件玩家.i_sys_speed);
			事件玩家.i_sys_pre_speed = 事件玩家.i_sys_speed;
		End;
	}
}

规则("系统-技能冷却-S")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(技能1)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(技能1)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(技能1), 技能冷却时间(事件玩家, 按钮(技能1)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(技能2)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(技能2), 技能冷却时间(事件玩家, 按钮(技能2)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-主武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(主要攻击模式)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(主要攻击模式)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(主要攻击模式), 技能冷却时间(事件玩家, 按钮(主要攻击模式)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(辅助攻击模式), 技能冷却时间(事件玩家, 按钮(辅助攻击模式)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("系统-技能冷却-跳跃")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.d_sys_cd > 0;
		技能冷却时间(事件玩家, 按钮(跳跃)) > 0;
	}

	动作
	{
		While(事件玩家.d_sys_cd > 0 && 技能冷却时间(事件玩家, 按钮(跳跃)) > 0);
			等待(1 - 较小(事件玩家.d_sys_cd, 1), 当为“假”时中止);
			设置技能冷却(事件玩家, 按钮(跳跃), 技能冷却时间(事件玩家, 按钮(跳跃)) - 较小(事件玩家.d_sys_cd, 1));
		End;
	}
}

规则("艾什-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 20, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
		等待(0.100, 无视条件);
		创建弹道(“法老之鹰”火箭, 事件玩家, 空, 矢量(X方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Y方向分量(面朝方向(事件玩家)) + 随机实数(-0.010, 0.010), Z方向分量(面朝方向(事件玩家))
			+ 随机实数(-0.010, 0.010)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 40, 0.250, 5, 有害爆炸, “法老之鹰”火箭发射器爆炸声音, 0, 40, 60, 0.300, 0, 15);
	}
}

禁用 规则("伊拉锐-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		伊拉锐;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		While(正在使用终极技能(事件玩家) == 真);
			If(空数组 != 范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障));
				创建追踪弹道(巴蒂斯特生化榴弹枪, 事件玩家, 所选位置(事件玩家), 空, 至地图, 治疗, 所在队伍(事件玩家), 50, 0.500, 3, 有益爆炸, 巴蒂斯特生化榴弹枪爆炸声音, 0, 10, 6, 0, 数组随机取值(范围内玩家(事件玩家, 15,
					所在队伍(事件玩家), 表面及敌方屏障)), 0.500);
			End;
			等待(0.500, 无视条件);
		End;
	}
}

规则("美-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		美;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置启用终极技能(事件玩家, 假);
		事件玩家.mei_Q_pos = 所选位置(事件玩家);
		事件玩家.mei_Q_timer = 总计消耗时间;
		事件玩家.mei_Q_dec = 面朝方向(事件玩家);
		事件玩家.mei_Q_pos = 矢量(X方向分量(事件玩家.mei_Q_pos) + X方向分量(事件玩家.mei_Q_dec) * 2, Y方向分量(事件玩家.mei_Q_pos), Z方向分量(事件玩家.mei_Q_pos) + Z方向分量(
			事件玩家.mei_Q_dec) * 2);
		While(总计消耗时间 - 事件玩家.mei_Q_timer <= 8);
			创建追踪弹道(美冰锥, 事件玩家, 空, 矢量(随机实数(-0.100, 0.100), 1, 随机实数(-0.100, 0.100)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(8,
				20), 6, 0, 数组随机取值(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 90), 存活(当前数组索引))), 随机实数(0.600, 1));
			创建追踪弹道(美冰锥, 事件玩家, 空, 矢量(随机实数(-0.100, 0.100), 1, 随机实数(-0.100, 0.100)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(8,
				20), 6, 0, 数组随机取值(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 90), 存活(当前数组索引))), 随机实数(0.600, 1));
			创建追踪弹道(美冰锥, 事件玩家, 空, 矢量(随机实数(-0.100, 0.100), 1, 随机实数(-0.100, 0.100)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 70, 2, 0, 有益爆炸, 爆炸声音, 0, 随机实数(8,
				20), 6, 0, 数组随机取值(已过滤的数组(视角中的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)), 90), 存活(当前数组索引))), 随机实数(0.600, 1));
			事件玩家.mei_Q_pos = 矢量(X方向分量(事件玩家.mei_Q_pos) + X方向分量(事件玩家.mei_Q_dec) * 0.200, Y方向分量(事件玩家.mei_Q_pos), Z方向分量(事件玩家.mei_Q_pos) + Z方向分量(
				事件玩家.mei_Q_dec) * 0.200);
			等待(0.050, 无视条件);
		End;
		设置终极技能充能(事件玩家, 0);
		设置启用终极技能(事件玩家, 真);
	}
}

规则("美-Q-暴击")
{
	事件
	{
		玩家造成伤害;
		双方;
		美;
	}

	条件
	{
		事件技能 == 0;
		事件暴击 == 真;
	}

	动作
	{
		设置状态(被攻击方, 事件玩家, 冰冻, 3);
	}
}

规则("猎空-能量")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("剩余能量：{0} - 剩余伤害：{1}", 较大(0, 全局.ci_tracer_max_energy - 事件玩家.tracer_energy), 较大(0,
			全局.ci_tracer_max_hit - 事件玩家.tracer_hit)), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("猎空-左键")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
		事件玩家.tracer_energy < 全局.ci_tracer_max_energy;
		事件玩家.tracer_energy_reset == 0;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真 && 事件玩家.tracer_energy < 全局.ci_tracer_max_energy);
			事件玩家.tracer_energy += 1;
			等待(0.050, 无视条件);
		End;
	}
}

规则("猎空-左键-冷却")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用主要武器(事件玩家) != 真;
		事件玩家.tracer_energy < 全局.ci_tracer_max_energy;
		事件玩家.tracer_energy_reset == 0;
		(事件玩家.tracer_energy > 0 || 事件玩家.tracer_hit > 0) == 真;
	}

	动作
	{
		等待直到 (正在使用主要武器(事件玩家), 3);
		While(正在使用主要武器(事件玩家) != 真 && 事件玩家.tracer_energy < 全局.ci_tracer_max_energy && (事件玩家.tracer_energy > 0 || 事件玩家.tracer_hit > 0));
			事件玩家.tracer_energy = 较大(0, 事件玩家.tracer_energy - 1);
			事件玩家.tracer_hit = 较大(0, 事件玩家.tracer_hit - 5);
			等待(0.200, 无视条件);
		End;
	}
}

规则("猎空-左键-过热")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		事件玩家.tracer_energy >= 全局.ci_tracer_max_energy;
	}

	动作
	{
		设置弹药(事件玩家, 0, 0);
		事件玩家.tracer_energy_reset = 总计消耗时间;
		While(
			事件玩家.tracer_energy >= 全局.ci_tracer_max_energy && 事件玩家.tracer_energy_reset != 0 && 总计消耗时间 - 事件玩家.tracer_energy_reset <= 1.800);
			等待(0.300, 无视条件);
			设置弹药(事件玩家, 0, 0);
		End;
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
		事件玩家.tracer_energy_reset = 0;
	}
}

规则("猎空-记录")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	动作
	{
		While(所用英雄(事件玩家) == 英雄(猎空));
			等待(3, 当为“假”时中止);
			事件玩家.tracer_energy_last = 事件玩家.tracer_energy;
			事件玩家.tracer_hit_last = 事件玩家.tracer_hit;
		End;
	}
}

规则("猎空-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 较小(事件玩家.tracer_energy, 事件玩家.tracer_energy_last);
	}
}

规则("猎空-左键-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		猎空;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		事件玩家.tracer_hit < 全局.ci_tracer_max_hit;
	}

	动作
	{
		伤害(被攻击方, 攻击方, 最大生命值(被攻击方) * 0.010);
		If((具有状态(被攻击方, 沉睡) || 具有状态(被攻击方, 冰冻) || 具有状态(被攻击方, 击倒) || 具有状态(被攻击方, 击晕) || 具有状态(被攻击方, 被入侵)) == 真);
			中止;
		End;
		事件玩家.tracer_hit = 较小(全局.ci_tracer_max_hit, 事件玩家.tracer_hit + 最大生命值(被攻击方) * 0.010);
	}
}

规则("猎空-换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家.tracer_energy + 事件玩家.tracer_hit > 0;
	}

	动作
	{
		事件玩家.tracer_energy = 999;
		事件玩家.tracer_hit = 999;
	}
}

规则("猎空-重生")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		猎空;
	}

	条件
	{
		在重生室中(事件玩家) == 真;
	}

	动作
	{
		事件玩家.tracer_energy = 0;
		事件玩家.tracer_hit = 0;
	}
}

规则("源氏-标记")
{
	事件
	{
		玩家造成伤害;
		双方;
		源氏;
	}

	条件
	{
		被攻击方.genji_flag >= 0;
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(辅助攻击模式) || 事件技能 == 按钮(近身攻击) || 事件技能 == 按钮(终极技能)) == 真;
	}

	动作
	{
		被攻击方.genji_flag = 较小(6, 被攻击方.genji_flag + (事件技能 == 按钮(终极技能) ? 6 : 2));
	}
}

规则("源氏-标记显示")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	动作
	{
		创建地图文本(事件玩家, 取整(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家))).genji_flag / 2, 上), 此栏位的玩家(0, 对方队伍(所在队伍(事件玩家))), 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色),
			默认可见度);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_map_text, 上一个文本ID, 总计消耗时间, -1, 英雄(源氏), 自定义字符串(
			"Genji Text"));
		创建地图文本(事件玩家, 取整(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家))).genji_flag / 2, 上), 此栏位的玩家(1, 对方队伍(所在队伍(事件玩家))), 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色),
			默认可见度);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_map_text, 上一个文本ID, 总计消耗时间, -1, 英雄(源氏), 自定义字符串(
			"Genji Text"));
		创建地图文本(事件玩家, 取整(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家))).genji_flag / 2, 上), 此栏位的玩家(2, 对方队伍(所在队伍(事件玩家))), 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色),
			默认可见度);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_map_text, 上一个文本ID, 总计消耗时间, -1, 英雄(源氏), 自定义字符串(
			"Genji Text"));
		创建地图文本(事件玩家, 取整(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家))).genji_flag / 2, 上), 此栏位的玩家(3, 对方队伍(所在队伍(事件玩家))), 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色),
			默认可见度);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_map_text, 上一个文本ID, 总计消耗时间, -1, 英雄(源氏), 自定义字符串(
			"Genji Text"));
		创建地图文本(事件玩家, 取整(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家))).genji_flag / 2, 上), 此栏位的玩家(4, 对方队伍(所在队伍(事件玩家))), 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色),
			默认可见度);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_map_text, 上一个文本ID, 总计消耗时间, -1, 英雄(源氏), 自定义字符串(
			"Genji Text"));
	}
}

规则("源氏-S")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(源氏);
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(近身攻击)) == 真;
	}

	动作
	{
		被攻击方.genji_flag = 取整(被攻击方.genji_flag / 2, 上);
		设置状态(被攻击方, 攻击方, 燃烧, 2.500);
		开始持续伤害(被攻击方, 攻击方, 2.500, (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.040 * 被攻击方.genji_flag);
		为玩家添加生命池(攻击方, 生命值, 10 * (被攻击方.genji_flag - 1), 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 2.500, 英雄(源氏));
		被攻击方.genji_flag = -999;
		等待(3, 无视条件);
		被攻击方.genji_flag = 0;
	}
}

规则("源氏-增伤")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 100, 假, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 12, 英雄(源氏), 自定义字符串(
			"Genji Dragonblade hp pool"));
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家, 150, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 7, 英雄(源氏), 自定义字符串(
			"Genji Dragonblade adjust"));
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 50, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 7, 英雄(源氏), 自定义字符串(
			"Genji Dragonblade adjust"));
		等待直到 (正在使用终极技能(事件玩家) != 真, 10);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Genji Dragonblade adjust") ? 数组分割(当前数组元素,
			0, 2) : 当前数组元素);
		等待(5, 无视条件);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Genji Dragonblade hp pool") ? 数组分割(当前数组元素,
			0, 2) : 当前数组元素);
	}
}

规则("源氏-E-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		源氏;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 50, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(源氏));
	}
}

规则("破坏球-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		破坏球;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.wrecking_ball_players = 范围内玩家(事件玩家, 8, 所在队伍(事件玩家), 表面及敌方屏障);
		开始伤害调整(事件玩家.wrecking_ball_players, 所有玩家(所在队伍(事件玩家)), 60, 无);
		事件玩家.wrecking_ball_dec_id = 上一个伤害调整ID;
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 事件玩家;
		等待(5, 无视条件);
		停止伤害调整(事件玩家.wrecking_ball_dec_id);
		事件玩家.wrecking_ball_players.wrecking_ball_dec = 0;
	}
}

规则("破坏球-减伤")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件玩家.wrecking_ball_dec != 0;
		攻击方 != 空;
	}

	动作
	{
		伤害(事件玩家.wrecking_ball_dec, 攻击方, 事件伤害 * 0.500);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(白色), 事件玩家, 1);
	}
}

规则("布丽吉塔-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.buligita_players = 范围内玩家(眼睛位置(事件玩家), 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
		设置状态(事件玩家.buligita_players, 事件玩家, 无敌, 0.300);
		开始伤害调整(事件玩家.buligita_players, 所有玩家(所有队伍), 85, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 11, 英雄(布丽吉塔),
			自定义字符串("Brigitte Rally"));
		创建效果(所有玩家(所有队伍), 火花, 颜色(黄色), 事件玩家, 8, 位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, 11, 英雄(布丽吉塔), 自定义字符串(
			"Brigitte Rally"));
		While(正在使用终极技能(事件玩家) == 真);
			事件玩家.buligita_players = 范围内玩家(眼睛位置(事件玩家), 8.500, 所在队伍(事件玩家), 表面及敌方屏障);
			事件玩家.buligita_players.i_sys_speed += 20;
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家.buligita_players, 20), 总计消耗时间, 0.200,
				英雄(布丽吉塔), 自定义字符串("Brigitte Rally"));
			等待直到 (正在使用终极技能(事件玩家) != 真, 0.200);
			等待直到 (!对任意为“真”(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Rally") && 当前数组元素[0] == 全局.t_enum_speed), 0.200);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Rally") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		事件玩家.buligita_players = 空;
	}
}

规则("奥丽莎-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		奥丽莎;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		施加推力(范围内玩家(事件玩家, 9, 对方队伍(所在队伍(事件玩家)), 表面及敌方屏障), 矢量(0, 1, 0), 8, 至地图, 取消相反运动);
		事件玩家.orisa_teammates = 从数组中移除(范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
		开始伤害调整(事件玩家.orisa_teammates, 所有玩家(对方队伍(所在队伍(事件玩家))), 60, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 6, 英雄(奥丽莎), 自定义字符串(
			"Orisa Terra Surge"));
		While(正在使用终极技能(事件玩家) == 真);
			事件玩家.orisa_teammates.orisa_master = 空;
			事件玩家.orisa_teammates = 从数组中移除(范围内玩家(事件玩家, 9, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
			事件玩家.orisa_teammates.orisa_master = 事件玩家;
			等待直到 (正在使用终极技能(事件玩家) != 真, 1);
		End;
		事件玩家.orisa_teammates.orisa_master = 空;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Orisa Terra Surge") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		事件玩家.orisa_teammates = 空;
	}
}

规则("奥丽莎-Q-吸收伤害")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件玩家.orisa_master != 空;
		正在使用终极技能(事件玩家.orisa_master) == 真;
		所在队伍(被攻击方) != 所在队伍(攻击方);
	}

	动作
	{
		伤害(事件玩家.orisa_master, 攻击方, 事件伤害 * 0.666);
		播放效果(从数组中移除(所有玩家(所有队伍), 事件玩家.orisa_master), 有害爆炸, 颜色(灰绿色), 事件玩家.orisa_master, 1);
	}
}

规则("卢西奥-Q")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置引力(事件玩家, 500);
		等待直到 (正在使用终极技能(事件玩家) != 真, 1);
		设置引力(事件玩家, 100);
		If(正在使用终极技能(事件玩家) == 真 && 存活(事件玩家) == 真);
			范围内玩家(事件玩家, 30, 所在队伍(事件玩家), 表面及敌方屏障).lucio_debuff_clear = 真;
		Else;
	}
}

规则("卢西奥-Q-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
	}

	动作
	{
		等待(6, 无视条件);
		事件玩家.lucio_debuff_clear = 假;
	}
}

规则("卢西奥-Q-负面状态清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_debuff_clear == 真;
		(具有状态(事件玩家, 冰冻) || 具有状态(事件玩家, 击倒) || 具有状态(事件玩家, 击晕) || 具有状态(事件玩家, 沉睡) || 具有状态(事件玩家, 燃烧) || 具有状态(事件玩家, 被入侵)) == 真;
	}

	动作
	{
		清除状态(事件玩家, 冰冻);
		清除状态(事件玩家, 沉睡);
		清除状态(事件玩家, 燃烧);
		清除状态(事件玩家, 击倒);
		清除状态(事件玩家, 击晕);
		清除状态(事件玩家, 被入侵);
		等待(0.100, 无视条件);
		清除状态(事件玩家, 冰冻);
		清除状态(事件玩家, 沉睡);
		清除状态(事件玩家, 燃烧);
		清除状态(事件玩家, 击倒);
		清除状态(事件玩家, 击晕);
		清除状态(事件玩家, 被入侵);
	}
}

规则("卢西奥-被动-滑墙")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		在墙上(事件玩家) == 真;
		在地面上(事件玩家) != 真;
	}

	动作
	{
		开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 90, 受伤害者和伤害者);
		事件玩家.lucio_slice_dec = 上一个伤害调整ID;
	}
}

规则("卢西奥-被动-冷静光环")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		While(存活(事件玩家));
			事件玩家.lucio_players = 范围内玩家(眼睛位置(事件玩家), 12, 所在队伍(事件玩家), 表面及敌方屏障);
			事件玩家.lucio_players.d_sys_cd += 全局.cd_lucio_cd_dec;
			事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_move_cd, 数组(事件玩家.lucio_players, 全局.cd_lucio_cd_dec),
				总计消耗时间, 0.200, 英雄(卢西奥), 自定义字符串("Lucio Crossfade"));
			等待(0.200, 无视条件);
			等待直到 (!对任意为“真”(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Lucio Crossfade")), 0.400);
		End;
	}
}

规则("卢西奥-被动-滑墙-解除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lucio_slice_dec != 空;
		(所用英雄(事件玩家) != 英雄(卢西奥) || 在墙上(事件玩家) != 真 || 在地面上(事件玩家)) == 真;
	}

	动作
	{
		停止伤害调整(事件玩家.lucio_slice_dec);
		事件玩家.lucio_slice_dec = 0;
	}
}

规则("卢西奥-E-强化强音")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		卢西奥;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
		数量(事件玩家.lucio_players) > 0;
	}

	动作
	{
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家.lucio_players, 115, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, 3, 英雄(卢西奥), 自定义字符串(
			"Lucio Amp It Up"));
	}
}

规则("黑影-伤害")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(黑影);
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(主要攻击模式)) == 真;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		If(事件玩家.sombra_player == 空);
			事件玩家.sombra_player = 攻击方;
			事件玩家.sombra_demage = 事件伤害;
			事件玩家.sombra_timer = 3;
		Else If(事件玩家.sombra_player == 攻击方);
			事件玩家.sombra_demage += 事件伤害;
			事件玩家.sombra_timer = 3;
		Else;
			中止;
		End;
		If(事件玩家.sombra_demage > 最大生命值(事件玩家) * 0.400);
			设置状态(事件玩家, 事件玩家.sombra_player, 被入侵, 3);
			事件玩家.sombra_hacked = 真;
			事件玩家.sombra_timer = 0;
			事件玩家.sombra_player = 空;
			事件玩家.sombra_demage = 0;
			等待(7, 无视条件);
			事件玩家.sombra_hacked = 假;
		End;
	}
}

规则("黑影-计时")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.sombra_player != 空;
		事件玩家.sombra_demage > 0;
		事件玩家.sombra_timer > 0;
		事件玩家.sombra_hacked != 真;
	}

	动作
	{
		While(事件玩家.sombra_timer > 0);
			等待直到 (事件玩家.sombra_timer <= 0, 1);
			事件玩家.sombra_timer -= 1;
		End;
		事件玩家.sombra_player = 空;
		事件玩家.sombra_demage = 0;
	}
}

规则("布丽吉塔-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用辅助武器(事件玩家) != 真, 1.500);
		创建效果(所有玩家(所有队伍), 环, 自定义颜色(248, 213, 97, 171), 事件玩家, 10, 可见，位置和半径);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_effect, 最后创建的实体, 总计消耗时间, -1, 英雄(布丽吉塔), 自定义字符串(
			"Brigitte Barrier Shield"));
		While(正在使用辅助武器(事件玩家) == 真);
			开始持续治疗(范围内玩家(眼睛位置(事件玩家), 10, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家, 0.500, 10);
			等待直到 (正在使用辅助武器(事件玩家) != 真, 0.500);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Barrier Shield") ? 数组分割(当前数组元素, 0,
			2) : 当前数组元素);
	}
}

规则("布丽吉塔-基础生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		布丽吉塔;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Brigitte Back") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		为玩家添加生命池(事件玩家, 护甲, 30, 真, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(布丽吉塔), 自定义字符串(
			"Brigitte Back"));
	}
}

规则("布丽吉塔-副武器-盾击")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		(所用英雄(攻击方) == 英雄(布丽吉塔) || 正在复制的英雄(攻击方) == 英雄(布丽吉塔)) == 真;
		事件技能 == 按钮(主要攻击模式);
		正在使用辅助武器(攻击方) == 真;
		正在使用终极技能(攻击方) != 真;
	}

	动作
	{
		设置状态(被攻击方, 攻击方, 击晕, 0.500);
	}
}

规则("布丽吉塔-s-护甲链枷")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		(所用英雄(攻击方) == 英雄(布丽吉塔) || 正在复制的英雄(攻击方) == 英雄(布丽吉塔)) == 真;
		事件技能 == 按钮(技能1);
	}

	动作
	{
		为玩家添加生命池(范围内玩家(眼睛位置(攻击方), 8.500, 所在队伍(攻击方), 表面及敌方屏障), 生命值, 最大生命值(被攻击方) * 0.100, 假, 假);
		攻击方.sys_default_status_pool[数量(攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(布丽吉塔), 自定义字符串(
			"Brigitte Shift"));
	}
}

规则("死神-被动-暗影")
{
	事件
	{
		玩家受到伤害;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) != 真;
		全局.random <= 0.100;
		事件玩家.ana_healing_preventing <= 0;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家, 相移, 0.500);
		等待(0.500, 无视条件);
	}
}

规则("死神-主武器-坦克杀手")
{
	事件
	{
		玩家造成伤害;
		双方;
		死神;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		数组包含(所有重装英雄, 所用英雄(被攻击方)) == 真;
	}

	动作
	{
		If(类型的生命值(被攻击方, 护甲) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.300);
		Else If(类型的生命值(被攻击方, 护盾) > 0);
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.200);
		Else;
			伤害(被攻击方, 事件玩家, 事件伤害 * 0.100);
		End;
	}
}

规则("死神-S-暗影")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待(0.410, 无视条件);
		设置状态(事件玩家, 事件玩家, 相移, 2);
		开始按下按钮(事件玩家, 按钮(技能1));
		等待直到 (正在使用技能 1(事件玩家) != 真, 3);
		停止按下按钮(事件玩家, 按钮(技能1));
		禁用按钮(事件玩家, 按钮(终极技能));
	}
}

规则("死神-暗影-特效")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		具有状态(事件玩家, 相移) == 真;
		事件玩家.reaper_shadow == 空;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 云, 颜色(紫色), 事件玩家, 1.500, 可见，位置和半径);
		事件玩家.reaper_shadow = 最后创建的实体;
	}
}

规则("死神-暗影-特效-消除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(英雄(死神) != 所用英雄(事件玩家) || 具有状态(事件玩家, 相移) != 真) == 真;
		事件玩家.reaper_shadow != 空;
	}

	动作
	{
		可用按钮(事件玩家, 按钮(终极技能));
		消除效果(事件玩家.reaper_shadow);
		事件玩家.reaper_shadow = 空;
	}
}

规则("死神-终极技能-高速绽放")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.i_sys_speed += 150;
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 100), 总计消耗时间, 1, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 20), 总计消耗时间, 1.500, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 10), 总计消耗时间, 2, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 10), 总计消耗时间, 2.500, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_speed, 数组(事件玩家, 10), 总计消耗时间, 3, 英雄(死神), 自定义字符串(
			"Reaper Death Blossom"));
	}
}

规则("DVA-被暴击")
{
	事件
	{
		玩家受到伤害;
		双方;
		D.Va;
	}

	条件
	{
		(事件暴击 || 事件技能 == 空) == 真;
		处于非初始状态(事件玩家) != 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 较大(事件伤害 * 0.500, 10) * (事件暴击 ? 1 : 0.300), 假, 真);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.500, 英雄(D.Va));
	}
}

规则("DVA-被动-飞行矩阵回复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		While(正在使用技能 1(事件玩家) == 真);
			设置技能资源(事件玩家, 按钮(辅助攻击模式), 2 + 技能资源(事件玩家, 按钮(辅助攻击模式)));
			等待直到 (正在使用技能 1(事件玩家) != 真, 0.100);
		End;
	}
}

规则("DVA-被动-护甲回复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		D.Va;
	}

	条件
	{
		事件玩家.dva_armor_recover == 空;
		类型的生命值(事件玩家, 护甲) > 0;
		处于非初始状态(事件玩家) != 真;
	}

	动作
	{
		开始持续治疗(事件玩家, 事件玩家, 9999999.000, 10);
		事件玩家.dva_armor_recover = 上一个持续治疗效果ID;
	}
}

规则("DVA-被动-护甲回复-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.dva_armor_recover != 空;
		(英雄(D.Va) != 所用英雄(事件玩家) || 处于非初始状态(事件玩家) || 类型的生命值(事件玩家, 护甲) <= 0) == 真;
	}

	动作
	{
		停止持续治疗(事件玩家.dva_armor_recover);
		事件玩家.dva_armor_recover = 空;
	}
}

规则("巴蒂斯特-S-临时生命")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, (最大生命值(事件玩家) - 生命值(事件玩家)) * 0.400, 假, 假);
		事件玩家.baptiste_shift_hp = 最后创建的生命池;
		事件玩家.sys_data_record[1] += (最大生命值(事件玩家) - 生命值(事件玩家)) * 0.400;
		等待(3, 无视条件);
		移除玩家的生命池(事件玩家.baptiste_shift_hp);
	}
}

规则("巴蒂斯特-主武器-附加伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		巴蒂斯特;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		伤害(被攻击方, 攻击方, 生命值(被攻击方) * 0.040);
	}
}

规则("巴蒂斯特-副武器-弹匣大小")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	动作
	{
		设置最大弹药(事件玩家, 1, 14);
		设置弹药(事件玩家, 1, 最大弹药(事件玩家, 1));
	}
}

规则("巴蒂斯特-副武器-双发扳机")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		巴蒂斯特;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
	}

	动作
	{
		等待(0.065, 无视条件);
		If(弹药(事件玩家, 1) > 0);
			创建弹道(巴蒂斯特生化榴弹枪, 事件玩家, 眼睛位置(事件玩家), 面朝方向(事件玩家), 至地图, 治疗, 所在队伍(事件玩家), 50, 1, 3, 有益爆炸, 巴蒂斯特生化榴弹枪爆炸声音, 0, 60, 6, 0, 0, 20);
			等待直到 (正在使用辅助武器(事件玩家) != 真, 0.500);
			等待(0.050, 无视条件);
			设置弹药(事件玩家, 1, 弹药(事件玩家, 1) - 1);
		End;
	}
}

规则("西格玛-Q-炮塔放置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		等待(0.500, 无视条件);
		If(存活(事件玩家) && 正在使用终极技能(事件玩家) != 真 && 具有状态(事件玩家, 被入侵) != 真);
			中止;
		End;
		事件玩家.sigma_battery_pos = 眼睛位置(事件玩家);
		创建效果(所有玩家(所在队伍(事件玩家)), 球, 颜色(蓝色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 数组(最后创建的实体);
		创建效果(所有玩家(对方队伍(所在队伍(事件玩家))), 球, 颜色(红色), 事件玩家.sigma_battery_pos, 15, 可见);
		事件玩家.sigma_battery_pic = 添加至数组(事件玩家.sigma_battery_pic, 最后创建的实体);
		等待(8, 无视条件);
		事件玩家.sigma_battery_pos = 空;
		消除效果(事件玩家.sigma_battery_pic[0]);
		消除效果(事件玩家.sigma_battery_pic[1]);
		事件玩家.sigma_battery_pic = 空;
	}
}

规则("西格玛-Q-炮塔攻击")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		西格玛;
	}

	条件
	{
		事件玩家.sigma_battery_pos != 空;
	}

	动作
	{
		While(事件玩家.sigma_battery_pos != 空);
			事件玩家.sigma_battery_target = 已排序的数组(范围内玩家(事件玩家.sigma_battery_pos, 15, 对方队伍(所在队伍(事件玩家)), 表面), 存活(当前数组元素) && !具有状态(事件玩家, 无敌) && !具有状态(
				事件玩家, 相移) ? 标准化生命值(当前数组元素) - (正在空中(当前数组元素) && !正在跳跃(当前数组元素) ? (标准化生命值(当前数组元素) >= 0.500 ? 1 : -1) : 0) : 9999)[0];
			If(事件玩家.sigma_battery_target != 空 && 存活(事件玩家.sigma_battery_target));
				If(正在空中(事件玩家.sigma_battery_target) && !正在跳跃(事件玩家.sigma_battery_target));
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						60, 0.300, 3, 有害爆炸, 爆炸声音, 0, 96, 0.156, 1.100, 0, 0);
					等待(0.335, 无视条件);
				Else;
					创建弹道(西格玛超能之球, 事件玩家, 事件玩家.sigma_battery_pos, 方向(事件玩家.sigma_battery_pos, 眼睛位置(事件玩家.sigma_battery_target)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
						30, 0.300, 3, 有害爆炸, 爆炸声音, 0, 48, 0.312, 1.100, 0, 0);
					等待(0.670, 无视条件);
				End;
			Else;
				等待(0.050, 无视条件);
			End;
		End;
		事件玩家.sigma_battery_target = 空;
	}
}

规则("安娜-被动-治疗护盾")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(安娜);
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 20, 假, 假);
		受治疗者.sys_default_status_pool[数量(受治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 0.500, 空);
	}
}

规则("安娜-E-禁疗强化")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(安娜);
		事件技能 == 按钮(技能2);
	}

	动作
	{
		事件玩家.ana_healing_preventing = 2;
		等待(3, 无视条件);
		事件玩家.ana_healing_preventing = 1;
		等待(2, 无视条件);
		事件玩家.ana_healing_preventing = 0;
	}
}

规则("安娜-E-禁疗状态")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ana_healing_preventing == 2;
	}

	动作
	{
		开始治疗调整(事件玩家, 所有玩家(所在队伍(事件玩家)), 50, 受治疗者，治疗者及治疗百分比);
		事件玩家.ana_healing_preventing_status = 上一个治疗调整ID;
	}
}

规则("安娜-E-禁疗清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.ana_healing_preventing == 0;
	}

	动作
	{
		停止治疗调整(事件玩家.ana_healing_preventing_status);
	}
}

规则("卡西迪-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		卡西迪;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 事件伤害 * 0.250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(卡西迪));
	}
}

规则("末日铁拳-被动-无损蓄力-副武器")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串(
			"Doomfist Rocket Punch"));
		等待直到 (按钮被按下(事件玩家, 按钮(辅助攻击模式)) != 真 || 正在使用辅助武器(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Rocket Punch") ? 数组分割(当前数组元素, 0,
			2) : 当前数组元素);
	}
}

规则("末日铁拳-被动-无损蓄力-E")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串(
			"Doomfist Power Block"));
		等待直到 (正在使用技能 2(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Power Block") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
	}
}

规则("末日铁拳-被动-无损蓄力-S")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		末日铁拳;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		为玩家添加生命池(事件玩家, 生命值, 250, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 5, 英雄(末日铁拳), 自定义字符串(
			"Doomfist Seismic Slam"));
		等待直到 (正在使用技能 1(事件玩家) != 真, 5);
		If((具有状态(事件玩家, 被入侵) || 具有状态(事件玩家, 击倒)) == 真);
			等待(1, 无视条件);
		End;
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Doomfist Seismic Slam") ? 数组分割(当前数组元素, 0,
			2) : 当前数组元素);
	}
}

规则("艾什-主武器-霰弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		艾什;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		If(!正在使用辅助武器(事件玩家));
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040), 随机实数(-0.040, 0.040)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060), 随机实数(-0.060, 0.060)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080), 随机实数(-0.080, 0.080)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)),
				2, 2, 0, 有害爆炸, 爆炸声音, 0, 800, 0.018, 0, 0, 0);
		Else;
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 8, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010), 随机实数(-0.010, 0.010)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 6, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
			创建弹道(“路霸”爆裂枪, 事件玩家, 空, 面朝方向(事件玩家) + 矢量(随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025), 随机实数(-0.025, 0.025)) * (正在跳跃(事件玩家) || 正在空中(事件玩家)
				? 1.500 : (正在蹲下(事件玩家) ? 0.800 : 1)), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 4, 2, 0, 有害爆炸, 爆炸声音, 0, 1000, 0.050, 0, 0, 0);
		End;
	}
}

规则("禅雅塔-被动-宁")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	动作
	{
		等待(5, 无视条件);
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Zenyata Tranquility") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		为玩家添加生命池(所有玩家(所在队伍(事件玩家)), 护甲, 15, 真, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, -1, 英雄(禅雅塔), 自定义字符串(
			"Zenyata Tranquility"));
	}
}

规则("禅雅塔-被动-破")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	条件
	{
		弹药(事件玩家, 0) % 2 == 0;
		弹药(事件玩家, 0) != 最大弹药(事件玩家, 0);
	}

	动作
	{
		等待直到 (!正在使用辅助武器(事件玩家), 99999);
		If(!存活(事件玩家.zenyata_target) || !在视野内(事件玩家, 事件玩家.zenyata_target, 90));
			事件玩家.zenyata_target = 距离准星最近的玩家(事件玩家, 对方队伍(所在队伍(事件玩家)));
		End;
		If(!存活(事件玩家.zenyata_target) || !在视野内(事件玩家, 事件玩家.zenyata_target, 90) || !在视线内(事件玩家, 事件玩家.zenyata_target, 敌方屏障阻挡视线));
			事件玩家.zenyata_target = 空;
		End;
		等待(0.100, 无视条件);
		创建追踪弹道(“秩序之光”光子发射器, 事件玩家, 空, 空, 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 48, 2, 0, 有益爆炸, 爆炸声音, 0.005, 60, 5, 0, 事件玩家.zenyata_target, 1);
	}
}

规则("禅雅塔-被动-破-索敌")
{
	事件
	{
		玩家造成伤害;
		双方;
		禅雅塔;
	}

	条件
	{
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		攻击方.zenyata_target = 被攻击方;
	}
}

规则("索杰恩-主武器-弹速增强")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		While(正在使用主要武器(事件玩家) == 真);
			设置弹道速度(事件玩家, 100000);
			等待直到 (正在使用主要武器(事件玩家) != 真, 1.500);
			中断;
		End;
		设置弹道速度(事件玩家, 100);
	}
}

规则("索杰恩-Q-伤害累积")
{
	事件
	{
		玩家造成伤害;
		双方;
		索杰恩;
	}

	条件
	{
		((事件技能 == 按钮(终极技能) && 正在使用终极技能(攻击方)) || (事件玩家.sojourn_Q_demage_count > 0 && 事件技能 == 按钮(辅助攻击模式))) == 真;
	}

	动作
	{
		伤害(被攻击方, 攻击方, 事件暴击 ? 攻击方.sojourn_Q_demage_count * 2 : 攻击方.sojourn_Q_demage_count);
		播放效果(所有玩家(所有队伍), 有害爆炸, 颜色(红色), 被攻击方, 1);
		If(正在使用终极技能(攻击方));
			攻击方.sojourn_Q_demage_count += 攻击方.sojourn_Q_demage_count > 120 ? 10 : 20;
		Else;
			攻击方.sojourn_Q_demage_count = 0;
		End;
	}
}

规则("索杰恩-Q-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sojourn_Q_demage_count = 0;
	}
}

规则("索杰恩-主武器-弹药")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		最大弹药(事件玩家, 0) < 450;
	}

	动作
	{
		设置最大弹药(事件玩家, 0, 450);
		设置弹药(事件玩家, 0, 450);
	}
}

规则("索杰恩-主武器-命中")
{
	事件
	{
		玩家造成伤害;
		双方;
		索杰恩;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		事件玩家.sojourn_bullet_count += 1;
	}
}

规则("索杰恩-主武器-弹药")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		弹药(事件玩家, 0) == 450;
	}

	动作
	{
		事件玩家.sojourn_bullet_count = 0;
	}
}

规则("索杰恩-主武器-换弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		事件玩家.sojourn_bullet_count >= 45;
		弹药(事件玩家, 0) != 450;
	}

	动作
	{
		While(弹药(事件玩家, 0) != 450 || 事件玩家.sojourn_bullet_count >= 45);
			设置弹药(事件玩家, 0, 0);
			等待(1.250, 当为“假”时中止);
		End;
	}
}

规则("索杰恩-文本显示")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		索杰恩;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("弹药：{0}", 45 - 事件玩家.sojourn_bullet_count), 自定义字符串("附加伤害：{0}", 事件玩家.sojourn_Q_demage_count), 自定义字符串(""), 顶部, 0,
			颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("温斯顿-副武器-蓄力")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		While((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) == 真);
			等待直到 ((正在使用辅助武器(事件玩家) && 按钮被按下(事件玩家, 按钮(辅助攻击模式))) != 真, 0.300);
			事件玩家.winston_power += 2;
		End;
		等待(0.500, 无视条件);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-副武器-击退")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		英雄(温斯顿) == 所用英雄(攻击方);
		事件技能 == 按钮(辅助攻击模式);
		攻击方.winston_power > 0;
	}

	动作
	{
		施加推力(被攻击方, 矢量(X方向分量(方向(攻击方, 被攻击方)), 0.250, Z方向分量(方向(攻击方, 被攻击方))),
			攻击方.winston_power < 10 ? 攻击方.winston_power * 2 : 攻击方.winston_power + 10, 至地图, 合并相反运动);
		事件玩家.winston_power = 0;
	}
}

规则("温斯顿-被动-伤害调整")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		温斯顿;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Winston Back") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		开始伤害调整(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(0, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(1, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(2, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(3, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
		开始伤害调整(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家))), 事件玩家, 较大(100 + 较小(生命值(事件玩家) - 生命值(此栏位的玩家(4, 对方队伍(所在队伍(事件玩家)))), 500) * 50 / 500, 100),
			受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(温斯顿),
			自定义字符串("Winston Back"));
	}
}

规则("查莉娅-被动-重力堡垒-HP记录")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	动作
	{
		While(真);
			事件玩家.zarya_hp_record_tmp = 添加至数组(事件玩家.zarya_hp_record, 生命值(事件玩家));
			If(数量(事件玩家.zarya_hp_record_tmp) > 10);
				事件玩家.zarya_hp_record = 数组分割(事件玩家.zarya_hp_record_tmp, 数量(事件玩家.zarya_hp_record_tmp) - 10, 10);
			Else;
				事件玩家.zarya_hp_record = 事件玩家.zarya_hp_record_tmp;
			End;
			等待(0.100, 无视条件);
		End;
	}
}

规则("查莉娅-文本栏")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("免伤：{0} - 治疗增幅：{1}", 100 - 较小(较大(首个(事件玩家.zarya_hp_record) - 最后(事件玩家.zarya_hp_record), 0) / 5, 40), 120 - 较小(
			较大(最后(事件玩家.zarya_hp_record) - 首个(事件玩家.zarya_hp_record), 0) / 10, 20)), 自定义字符串(""), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("查莉娅-被动-重力堡垒-调整")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		(事件玩家.zarya_weaken == 空 || 事件玩家.zarya_heal_inc == 空) == 真;
	}

	动作
	{
		If(事件玩家.zarya_weaken == 空);
			开始伤害调整(事件玩家, 所有玩家(对方队伍(所在队伍(事件玩家))), 100 - 较小(较大(首个(事件玩家.zarya_hp_record) - 最后(事件玩家.zarya_hp_record), 0) / 5, 40), 受伤害者，伤害者及伤害百分比);
			事件玩家.zarya_weaken = 上一个伤害调整ID;
		End;
		If(事件玩家.zarya_heal_inc == 空);
			开始治疗调整(事件玩家, 所有玩家(所在队伍(事件玩家)), 120 - 较小(较大(最后(事件玩家.zarya_hp_record) - 首个(事件玩家.zarya_hp_record), 0) / 10, 20), 受治疗者，治疗者及治疗百分比);
			事件玩家.zarya_heal_inc = 上一个治疗调整ID;
		End;
	}
}

规则("查莉娅-被动-重力堡垒-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		英雄(查莉娅) != 所用英雄(事件玩家);
		(事件玩家.zarya_weaken != 空 || 事件玩家.zarya_heal_inc != 空) == 真;
	}

	动作
	{
		If(事件玩家.zarya_weaken != 空);
			停止伤害调整(事件玩家.zarya_weaken);
			事件玩家.zarya_weaken = 空;
		End;
		If(事件玩家.zarya_heal_inc != 空);
			停止治疗调整(事件玩家.zarya_heal_inc);
			事件玩家.zarya_heal_inc = 空;
		End;
	}
}

规则("查莉娅-主武器-爆头")
{
	事件
	{
		玩家造成伤害;
		双方;
		查莉娅;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 15, 被攻击方, 事件玩家, 真), 眼睛位置(被攻击方)) < 0.300;
	}

	动作
	{
		播放效果(事件玩家, 有害选择效果 , 颜色(红色), 眼睛位置(被攻击方), 0.500);
		伤害(被攻击方, 事件玩家, 事件伤害 * 0.500);
	}
}

规则("查莉娅-被动-弹药恢复")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		查莉娅;
	}

	条件
	{
		(正在使用技能 1(事件玩家) || 正在使用技能 2(事件玩家)) == 真;
	}

	动作
	{
		设置弹药(事件玩家, 0, 较小(最大弹药(事件玩家, 0), 弹药(事件玩家, 0) + 25));
	}
}

规则("秩序之光-Q-大招增幅")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		秩序之光;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		创建效果(事件玩家, 火花, 颜色(天蓝色), 事件玩家, 15, 可见，位置和半径);
		事件玩家.symmetra_Q_effect = 最后创建的实体;
		While((正在使用终极技能(事件玩家) && 存活(事件玩家)) == 真);
			事件玩家.symmetra_Q_players = 从数组中移除(范围内玩家(事件玩家, 15, 所在队伍(事件玩家), 表面及敌方屏障), 事件玩家);
			For 玩家变量(事件玩家, symmetra_Q_inedx, 0, 数量(事件玩家.symmetra_Q_players), 1);
				设置终极技能充能(事件玩家.symmetra_Q_players[事件玩家.symmetra_Q_inedx], 终极技能充能百分比(事件玩家.symmetra_Q_players[事件玩家.symmetra_Q_inedx]) + 1);
				等待直到 ((正在使用终极技能(事件玩家) && 存活(事件玩家)) != 真, 0);
			End;
			事件玩家.symmetra_Q_inedx = 0;
			等待直到 ((正在使用终极技能(事件玩家) && 存活(事件玩家)) != 真, 0.430);
		End;
		消除效果(事件玩家.symmetra_Q_effect);
		事件玩家.symmetra_Q_effect = 空;
	}
}

规则("秩序之光-伤害")
{
	事件
	{
		玩家造成伤害;
		双方;
		秩序之光;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		为玩家添加生命池(范围内玩家(眼睛位置(事件玩家), 8, 所在队伍(事件玩家), 表面及敌方屏障), 生命值, 事件伤害 * 0.300, 假, 假);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(秩序之光));
	}
}

规则("渣客女王-被动-标记")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(渣客女王);
		(事件技能 == 按钮(技能2) || 事件技能 == 按钮(辅助攻击模式) || 事件技能 == 按钮(近身攻击) || 事件技能 == 按钮(终极技能)) == 真;
	}

	动作
	{
		被攻击方.junkerqueen_timer = 0.400;
		If(被攻击方.junkerqueen_effect != 空 && 攻击方 != 被攻击方.junkerqueen_effect[0]);
			停止伤害调整(事件玩家.junkerqueen_effect[1]);
			停止治疗调整(事件玩家.junkerqueen_effect[2]);
			事件玩家.junkerqueen_effect = 空;
		End;
		If(被攻击方.junkerqueen_effect == 空);
			被攻击方.junkerqueen_effect = 数组(攻击方);
			开始伤害调整(所有玩家(所在队伍(攻击方)), 被攻击方, 85, 受伤害者和伤害者);
			被攻击方.junkerqueen_effect = 添加至数组(被攻击方.junkerqueen_effect, 上一个伤害调整ID);
			开始治疗调整(被攻击方, 所有玩家(所有队伍), 85, 受治疗者和治疗者);
			被攻击方.junkerqueen_effect = 添加至数组(被攻击方.junkerqueen_effect, 上一个治疗调整ID);
		End;
	}
}

规则("渣客女王-被动-标记-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.junkerqueen_timer <= 0;
		事件玩家.junkerqueen_effect != 空;
	}

	动作
	{
		停止伤害调整(事件玩家.junkerqueen_effect[1]);
		停止治疗调整(事件玩家.junkerqueen_effect[2]);
		事件玩家.junkerqueen_effect = 空;
	}
}

规则("渣客女王-shift-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sys_players_record[0] = 0;
		事件玩家.sys_players_record[1] = 空;
		事件玩家.sys_players_record[2] = 范围内玩家(眼睛位置(事件玩家), 15, 所在队伍(事件玩家), 表面及敌方屏障);
		While(事件玩家.sys_players_record[0] < 数量(事件玩家.sys_players_record[2]));
			事件玩家.sys_players_record[1] = 事件玩家.sys_players_record[2][事件玩家.sys_players_record[0]];
			If(事件玩家.sys_players_record[1] == 事件玩家);
				事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns)] = 数组(0.300, 总计消耗时间, 5, 英雄(渣客女王), 自定义字符串("Junker Queen Commanding Shout"), 事件玩家);
			Else;
				事件玩家.sys_players_record[1].sys_status_thorns[数量(事件玩家.sys_players_record[1].sys_status_thorns)] = 数组(0.250, 总计消耗时间, 3, 空, 自定义字符串(
					"Junker Queen Commanding Shout"), 事件玩家);
			End;
			事件玩家.sys_players_record[0] += 1;
		End;
		事件玩家.sys_players_record = 空;
	}
}

规则("渣客女王-E-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns)] = 数组(0.850, 总计消耗时间, 5, 英雄(渣客女王), 自定义字符串("Junker Queen Carnage"), 事件玩家);
		等待直到 (!正在使用技能 2(事件玩家), 5);
		事件玩家.sys_status_thorns = 已过滤的数组(事件玩家.sys_status_thorns, 当前数组元素[4] != 自定义字符串("Junker Queen Carnage"));
	}
}

规则("渣客女王-终极技能-荆棘")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		事件玩家.sys_status_thorns[数量(事件玩家.sys_status_thorns)] = 数组(0.200, 总计消耗时间, 6, 英雄(渣客女王), 自定义字符串("Junker Queen Rampage"), 事件玩家);
		等待直到 (!正在使用终极技能(事件玩家), 6);
		事件玩家.sys_status_thorns = 已过滤的数组(事件玩家.sys_status_thorns, 当前数组元素[4] != 自定义字符串("Junker Queen Rampage"));
	}
}

规则("渣客女王-初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		事件玩家.sys_self_text == 空;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("荆棘造成伤害：{0}", 事件玩家.sys_data_record[1]), 自定义字符串(""), 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("黑百合-副武器-开镜-护盾")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		黑百合;
	}

	条件
	{
		正在使用辅助武器(事件玩家) == 真;
		事件玩家.widowmaker_hp_pool == 空;
		事件玩家.widowmaker_hp_pool_timer <= 0;
	}

	动作
	{
		等待(0.200, 当为“假”时中止);
		为玩家添加生命池(事件玩家, 生命值, 300, 假, 假);
		事件玩家.widowmaker_hp_pool = 最后创建的生命池;
	}
}

规则("黑百合-副武器-开镜-护盾破碎")
{
	事件
	{
		玩家受到伤害;
		双方;
		黑百合;
	}

	条件
	{
		事件玩家.widowmaker_hp_pool != 空;
	}

	动作
	{
		等待(0.300, 当为“假”时中止);
		播放效果(攻击方, “末日铁拳”上勾重拳击中声音, 颜色(白色), 攻击方, 9999);
		播放效果(被攻击方, “末日铁拳”上勾重拳击中声音, 颜色(白色), 被攻击方, 9999);
		事件玩家.widowmaker_hp_pool_timer = 正在使用终极技能(事件玩家) ? 2 : 6;
	}
}

规则("黑百合-副武器-开镜-护盾清除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.widowmaker_hp_pool != 空;
		(所用英雄(事件玩家) != 英雄(黑百合) || 正在使用辅助武器(事件玩家) != 真 || 事件玩家.widowmaker_hp_pool_timer > 0) == 真;
	}

	动作
	{
		移除玩家的生命池(事件玩家.widowmaker_hp_pool);
		事件玩家.widowmaker_hp_pool = 空;
	}
}

规则("黑百合-Q-弹匣拓展")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		黑百合;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		设置最大弹药(事件玩家, 0, 70);
		设置弹药(事件玩家, 0, 弹药(事件玩家, 0) + 35);
		等待直到 (正在使用终极技能(事件玩家) != 真, 20);
		设置最大弹药(事件玩家, 0, 35);
	}
}

规则("黑百合-Q-伤害增幅")
{
	事件
	{
		玩家造成伤害;
		双方;
		黑百合;
	}

	条件
	{
		正在使用终极技能(攻击方) == 真;
		正在使用辅助武器(攻击方) == 真;
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		伤害(被攻击方, 攻击方, 事件伤害);
	}
}

规则("堡垒-坦克炮弹")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		堡垒;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 真;
	}

	动作
	{
		While(正在使用技能 1(事件玩家) && 正在使用主要武器(事件玩家));
			If(全局.random < 水平速度(事件玩家) * 0.160);
				创建弹道(“法老之鹰”火箭, 事件玩家, 眼睛位置(事件玩家), 面朝方向(事件玩家), 至地图, 伤害, 对方队伍(所在队伍(事件玩家)), 30 + 最大生命值(事件玩家) * 0.100, 0.500, 3, 有害爆炸, 爆炸声音, 0, 60, 3,
					0, 0, 0);
			End;
			等待(0.500, 无视条件);
		End;
	}
}

规则("路霸-文字")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		路霸;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串(""), 自定义字符串("单打独斗 强化：{0}% 强化近身攻击：{1}%", 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, (数量(
			已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) + 1) * 5), 自定义字符串(""), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.sys_self_text = 数组(所用英雄(事件玩家), 上一个文本ID);
	}
}

规则("路霸-被动-单打独斗")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		路霸;
	}

	动作
	{
		事件玩家.sys_default_status_pool = 映射的数组(事件玩家.sys_default_status_pool, 当前数组元素[5] == 自定义字符串("Roadhog Alone") ? 数组分割(当前数组元素, 0, 2)
			: 当前数组元素);
		开始伤害调整(所有玩家(对方队伍(所在队伍(事件玩家))), 事件玩家, 100 + 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串(
			"Roadhog Alone"));
		开始伤害调整(事件玩家, 所有玩家(所有队伍), 100 - 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, 受伤害者，伤害者及伤害百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_damage_adjust, 上一个伤害调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串(
			"Roadhog Alone"));
		开始治疗调整(事件玩家, 所有玩家(所有队伍), 100 + 数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) * 8, 受治疗者，治疗者及治疗百分比);
		事件玩家.sys_default_status_pool[数量(事件玩家.sys_default_status_pool)] = 数组(全局.t_enum_heal_adjust, 上一个治疗调整ID, 总计消耗时间, -1, 英雄(路霸), 自定义字符串(
			"Roadhog Alone"));
	}
}

规则("路霸-被动-单打独斗-移除")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.roadhog_mates_flag == 真;
	}

	动作
	{
		等待(5, 当为“假”时中止);
		事件玩家.roadhog_mates_flag = 假;
	}
}

规则("路霸-被动-单打独斗-队友阵亡")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	动作
	{
		事件玩家.roadhog_mates_flag = 真;
	}
}

规则("路霸-被动-单打独斗-钩子标记")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件技能 == 按钮(技能1);
		所用英雄(攻击方) == 英雄(路霸);
		正在使用技能 1(攻击方) == 真;
	}

	动作
	{
		攻击方.roadhog_hit_flag = 数组(1, 被攻击方);
	}
}

规则("路霸-被动-单打独斗-近身攻击")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		事件技能 == 按钮(主要攻击模式);
		所用英雄(攻击方) == 英雄(路霸);
		攻击方.roadhog_hit_flag[0] > 0;
		攻击方.roadhog_hit_flag[1] == 被攻击方;
	}

	动作
	{
		攻击方.roadhog_hit_flag = 空;
		等待直到 (!正在使用主要武器(攻击方), 1);
		伤害(被攻击方, 攻击方, 最大生命值(被攻击方) * (数量(已过滤的数组(所有玩家(所在队伍(事件玩家)), 当前数组元素.roadhog_mates_flag == 真)) + 1) * 0.080);
	}
}

规则("伊拉锐-护盾发生器")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(伊拉锐);
		事件技能 == 空;
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 正在使用终极技能(治疗者) == 真 ? 120 : 60, 假, 真);
		治疗者.sys_default_status_pool[数量(治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.500, 英雄(伊拉锐));
		受治疗者.illari_poison = 治疗者;
		等待(0.500, 无视条件);
	}
}

规则("伊拉锐-右键-护盾发生器")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(伊拉锐);
		事件技能 == 按钮(主要攻击模式);
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 事件治疗 * 10.0, 假, 真);
		治疗者.sys_default_status_pool[数量(治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 2.00, 英雄(伊拉锐));
	}
}

规则("伊拉锐-烈日强化")
{
	事件
	{
		玩家造成伤害;
		双方;
		全部;
	}

	条件
	{
		(事件技能 == 按钮(主要攻击模式) || 事件技能 == 按钮(辅助攻击模式)) == 真;
		攻击方.illari_poison != 空;
	}

	动作
	{
		伤害(被攻击方, 攻击方.illari_poison, 事件伤害 * 0.20);
		攻击方.illari_poison = 空;
	}
}

规则("拉玛刹-增加吸血")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		拉玛刹;
	}

	条件
	{
		(正在使用技能 1(事件玩家) || 正在使用终极技能(事件玩家)) == 真;
	}

	动作
	{
		事件玩家.ramattra_absorb = 0.500;
	}
}

规则("拉玛刹-去除吸血")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		((!正在使用技能 1(事件玩家) && !正在使用终极技能(事件玩家)) || (所用英雄(事件玩家) != 英雄(拉玛刹))) == 真;
		事件玩家.ramattra_absorb > 0;
	}

	动作
	{
		事件玩家.ramattra_absorb = 0;
	}
}

规则("拉玛刹-吸血")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(拉玛刹);
		攻击方.ramattra_absorb > 0;
		(事件技能 == 按钮(技能1) || 事件技能 == 按钮(终极技能)) == 真;
	}

	动作
	{
		开始持续治疗(攻击方, 攻击方, 0.500, 攻击方.ramattra_absorb * 事件伤害 * 2);
	}
}

规则("莱因哈特-被动-守护-伤害累计")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(被攻击方) == 英雄(莱因哈特);
	}

	动作
	{
		If(被攻击方.reinhardt_shield[1] + 事件伤害 > 生命值(被攻击方) * 0.300);
			被攻击方.reinhardt_shield = 数组(0, 0);
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 0.500, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.500, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 2, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 2.500, 英雄(莱因哈特));
			为玩家添加生命池(被攻击方, 生命值, 12 + (最大生命值(被攻击方) - 生命值(被攻击方)) * 0.020, 假, 假);
			被攻击方.sys_default_status_pool[数量(被攻击方.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 3, 英雄(莱因哈特));
			等待(10, 当为“假”时中止);
		End;
		被攻击方.reinhardt_shield = 数组(3, 被攻击方.reinhardt_shield[1] + 事件伤害);
		Else;
	}
}

规则("莱因哈特-被动-守护-清理")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		莱因哈特;
	}

	条件
	{
		事件玩家.reinhardt_shield != 空;
		事件玩家.reinhardt_shield[1] > 0;
		事件玩家.reinhardt_shield[0] <= 0;
	}

	动作
	{
		事件玩家.reinhardt_shield = 数组(0, 0);
	}
}

规则("莱因哈特-终极技能-迅猛烈焰")
{
	事件
	{
		玩家受到伤害;
		双方;
		全部;
	}

	条件
	{
		所用英雄(攻击方) == 英雄(莱因哈特);
		事件技能 == 按钮(终极技能);
	}

	动作
	{
		等待直到 (具有状态(被攻击方, 击倒), 5);
		If(具有状态(被攻击方, 击倒));
			等待(随机实数(0.300, 0.800), 无视条件);
			创建弹道(莱因哈特烈焰打击, 攻击方, 所选位置(被攻击方) + 矢量(0, 10, 0), 下, 至地图, 伤害, 所在队伍(被攻击方), 120, 0.200, 3, 有害爆炸, 爆炸声音, 0, 25, 5, 0, 0, 0);
		End;
	}
}

规则("士兵76-E-护盾")
{
	事件
	{
		玩家受到治疗;
		双方;
		全部;
	}

	条件
	{
		所用英雄(治疗者) == 英雄(士兵：76);
		事件技能 == 按钮(技能2);
	}

	动作
	{
		为玩家添加生命池(受治疗者, 生命值, 3, 假, 假);
		治疗者.sys_default_status_pool[数量(治疗者.sys_default_status_pool)] = 数组(全局.t_enum_hp_pool, 最后创建的生命池, 总计消耗时间, 1.200, 英雄(士兵：76));
	}
}

禁用 规则("debug-hp")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		创建地图文本(所有玩家(所有队伍), 自定义字符串("{0} / {1}", 生命值(事件玩家), 最大生命值(事件玩家)), 事件玩家, 1, 根据表面截取, 可见，位置，字符串和颜色, 颜色(白色), 默认可见度);
	}
}

规则("")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		While(真);
			事件玩家.debug_1 = 自定义字符串("{0} {1}", 事件玩家.illari_poison[0][1], 事件玩家.illari_poison[0][2]);
			等待(0.100, 无视条件);
		End;
	}
}

规则("debug")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		事件玩家.d_sys_cd = 0.500;
		设置终极技能充能(事件玩家, 100);
		If(事件玩家.debug_robot == 空);
			创建HUD文本(事件玩家, 自定义字符串("{0} - {1}", 事件玩家.debug_2, 技能资源(事件玩家, 按钮(辅助攻击模式))), 自定义字符串("shift：{0} E：{1} Q：{2}", 正在使用技能 1(事件玩家), 正在使用技能 2(
				事件玩家), 正在使用终极技能(事件玩家)), 自定义字符串("主武器：{0} 副武器：{1} {2}", 正在使用主要武器(事件玩家), 正在使用辅助武器(事件玩家), 自定义字符串("{0} - {1} - {2}", 正在人格复制(事件玩家),
				正在复制的英雄(事件玩家), 速度(事件玩家))), 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
			生成机器人(英雄(奥丽莎), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			事件玩家.debug_robot2 = 最后创建的实体;
			生成机器人(英雄(卢西奥), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(雾子), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			生成机器人(英雄(托比昂), 队伍2, -1, 事件玩家, 矢量(0, 0, 0));
			事件玩家.debug_robot = 最后创建的实体;
			// 开始持续伤害(所有玩家(所在队伍(事件玩家)), 事件玩家.debug_robot, 99999, 30);
		Else;
			传送(所有玩家(所有队伍), 事件玩家);
		End;
		等待(1, 无视条件);
		设置终极技能充能(事件玩家.debug_robot, 100);
		设置终极技能充能(事件玩家.debug_robot2, 100);
		等待(1, 无视条件);
		开始按下按钮(事件玩家.debug_robot, 按钮(终极技能));
		开始按下按钮(事件玩家.debug_robot2, 按钮(终极技能));
		等待(1, 无视条件);
	}
}

规则("debug_hit")
{
	事件
	{
		玩家造成伤害;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		事件玩家.debug_2 = 字符串("{0} - {1}", 事件伤害, 事件技能);
	}
}

规则("debug_heal")
{
	事件
	{
		玩家造成治疗;
		双方;
		全部;
	}

	条件
	{
		正在等待玩家 == 真;
	}

	动作
	{
		事件玩家.debug_2 = 字符串("{0} - {1}", 事件治疗, 事件技能);
	}
}